{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}{\f1\fswiss Arial;}{\f2\froman\fcharset0 Times New Roman;}{\f3\fnil\fprq1\fcharset0 Lucida Console;}{\f4\fnil Consolas;}{\f5\fnil Lucida Console;}{\f6\fnil\fcharset0 Lucida Console;}{\f7\fnil\fcharset0 Calibri;}{\f8\fnil\fcharset0 Consolas;}{\f9\fnil\fcharset2 Symbol;}}
{\colortbl ;\red0\green0\blue255;\red43\green145\blue175;\red0\green255\blue0;\red255\green255\blue0;\red163\green21\blue21;\red0\green128\blue0;\red0\green0\blue0;\red255\green255\blue255;\red30\green30\blue30;\red230\green231\blue232;\red47\green79\blue79;\red255\green0\blue0;\red128\green128\blue128;}
{\*\generator Riched20 6.3.9600}\viewkind4\uc1 
\pard\b\f0\fs48 Holofunk notes: \fs20\par
\b0\par
\b\fs36 KEEP:\b0\fs20\par
\par
- On the M-Audio interface:\par
\tab - left bottom signal pot: maxed\par
\tab - input 1: both buttons OUT (Inst / No Pad)\par
\tab - Stereo button OUT\line\tab - Mix: all the way to the right (PB)\line\tab - Output (below Mix): minned\par
\tab - A/B: OUT\par
\tab - Level: fairly high\par
- In Windows:\line\tab - Master level: maxed\par
\tab - System sounds: maxed\par
\tab - Line 1/2 (M-Audo FastTrack Pro): MINNED\par
\tab\tab - this prevents hearing the mic while recording it\par
\par
INSTALL 6.0.7 M-AUDIO FASTTRACKPRO DRIVERS:\par
{{\field{\*\fldinst{HYPERLINK http://avid.force.com/pkb/articles/en_US/Download/Fast-Track-Pro-Drivers }}{\fldrslt{http://avid.force.com/pkb/articles/en_US/Download/Fast-Track-Pro-Drivers\ul0\cf0}}}}\f0\fs20\par
\par
\par
\i Install Fast Track Pro 6.0.7 drivers\b\i0\par
In Scarlett Mixer:\par
\b0 - select 48Khz\par
- set MINIMUM LATENCY\par
\par
\par
\b In Windows Audio control panel: right-click speaker icon\par
\b0\i DO NOT make ASIO devices be the default audio devices\i0\par
Playback Devices, Line 1/2 Properties, Advanced, 2 channel / 24 bit / 48KHz quality\par
\tab Check both boxes\par
Recording Devices, Line 1/2 Properties, Advanced, 2 channel / 24 bit / 48KHz quality\par
\tab Check both boxes\par
\par
IF GET HORRIBLE STATIC THAT BLOWS YOUR HEAD OFF: reboot immediately\par
IF GET SCRATCHY GARBLE (especially if breakpointing in asioprocs): reboot immediately\par
\par
\par
\b GREAT!!!\par
\b0\par
\b DO NOT FORGET THAT ONCE PANNING GOES LIVE, THE CABLE TO THE PA SYSTEM MUST REVERSE THE CHANNELS!  \b0 If the video is flipped horizontally, the audience audio must be as well!\par
\par
\b REMEMBER EARBUD OR OTHER HEADPHONES WHENEVER GIGGING LIVE!\par
\b0 look into wireless solution???  or just wing it....\par
\par
Idea: run the audio out of the M-Audio into a three-way splitter -- camera (for recording), PA system, and wireless Bluetooth stereo adapter.  The latter drives the headsets.  How low will the latency be?  Only one way to find out....\par
\b\par
\b0 OM GOM GOM GOMGOGM GOMDG OGMGOMGOGM\line TURRRHNNAAAADDOOOOO\line\par
FreezeVerb > FreezeVerb\par
Granulizer > PitchDrop\par
Guitar Amp > Boost\par
Guitar Amp > NiceDynamics\par
Levelizer > Kompressor\par
Pan Looper > SizeIT\par
Pan Looper > Zapper\par
Pitch Delay > Stutter Delay\par
Pitch Looper > BitchLooper\par
Pitch Looper > Pitch Looper\par
Reactor > AcidBath\par
Reactor > BreakBeater\par
Reactor > StrangeTone\par
Reverb > Medium Hall\par
Reverb > Reverb\par
RingModulator > RingModulator\par
RingModulator > Wobbler\par
Slicearranger > Bassgun\par
SliceArranger > PushMe\par
Slicearranger > SliceWarz\par
Slicearranger > ThreeFee\par
Spectralizer > Backgroundbreak\par
Spectralizer > RainingMallets\par
Tonalizer > Airplane\par
Vinylizer > FastStops\par
Vinylizer > Vinylizer\par
Vocodizer > Minorchords\par
Vocodizer > Sequence\par
\b\par
COOLEST BEARDYSHIT:\par
- Into The Abyss\par
- Nice Pitch Shifter\par
- That's Disgusting\par
- whosaiddubstepwasdead\par
\b0\par
WATCH OUT FOR GREEN USB LIGHT ON FRONT OF SCARLETT 6i6.\par
IF IT GOES OUT,MAY BE RESTART TIME.\par
Seems some crashes hork the whole USB hub and reboot is required; unplug/replug/power-cycle on Scarlett don't cut it.\par
\par
\b UM HOLY SHIT PERSISTENT SCARLETT ASIO_START FAILURE LASTED FOREVER BUT FINALLY WHEN DOUBLING ARGUMENT TO ASIO_START FROM 128 TO 256 STARTED WORKING\b0 .\par
\par
wow. That's the shit you only find by headbanging. OUCH\par
\par
AND AND AND, if it does get into fucked BASS_ERROR_UNKNOWN state, restart the XPS12 AND power cycle the Scarlett.  That does seem to revive it.\par
\par
OR, for BASS_ERROR_UNKNOWN, kill "Windows Audio Graph Device Isolation" service -- try to change sample rate in MixControl and if it complains that audiodg.exe is still holding ASIO, blow "Windows Audio Graph" process away and then Holofunk will run.\par
Interestingly, the first time after doing this, get the usual "no blinky" ASIO startup issue; restarting resolves as normal for that situation.\par
\par
\par
\par
\par
\b\fs36 TO DO:\par
\b0\fs20\par
- see if release mode is any faster - \b YES\b0\par
\par
Implement "hand up" gesture plus volume detection for new-player registration.\par
\b - Nah, just revive the "player swap" menu command.  (which really just swaps ASIO channels now)\par
\tab - (no, it swaps the body registration at the Kinect level)\par
\b0\tab - \b DONE\par
\par
 - player switching menu command \par
\par
\b0 nuff said\b\par
\par
\b0\par
\par
\par
\par
- fix stupid beats math bug with 44.1Khz sample rate, so can test Turnado BPM issues at that speed\par
\par
- see if turnado tempo locks properly at 120Hz and 44.1Khz\par
- if so, try it at 120Hz and 48KHz\par
- then at 130.625Hz and 48KHz\par
\par
\par
- then hack the tempo to 90 and try it\par
\tab - at least that would give Turnado tempo sync for one preset-in-source-code non-changeable tempo\par
\tab - that's fine for Monster Planet\par
\par
\par
\par
\par
- experiment more with Turnado, find some more insane effects\par
\par
\par
\par
- further optimize color blitting, make a map to avoid redundant color copying (and profile how much it wins)\par
\par
\par
- sort out lingering bug with player swap (body hangs around, state machine doesn't get unwound, possible persistent touched loopie being recycled)\par
\par
\par
\par
- put tempo support into VST library - YES THIS, unlocks so many effects\par
\par
- pull the git repo for the VST library, push the tempo change\par
\par
- research WTH Robert@SugarBytes means by the "PPC timing" or "PCP" or WTF ever\par
\par
\par
\par
\par
\par
- blow chunks all over Turnado (to optimize startup program init across 50 Turnados)\par
\par
\par
\par
\par
- integrate setup form, BassAsio changes, BassVst changes, etc. all back to Holofunk\par
\par
\par
\par
\par
\par
\par
\par
ALPHA TEST MUST-HAVE FEATURES:\par
\b\par
 - pixel shader effects\b0\par
\par
get the SharpDX toolkit pixel shader example building somehow\par
modify it in place to produce a variety of effects\par
try to get it to apply effects to a toolkit bitmap (specifically, grayscaling it)\par
migrate the code into Holofunk to initially support grayscaling muted images\par
\b\par
 - FFT recording\par
\par
\b0 initially build it into BATT for ease of prototyping the visualization\par
or choose a quick and dirty (and expensive) bar graph texture renderer\par
visualize it with varying degrees of decay\b\par
\par
 - FFT-driven pixel shaders\par
\par
\b0 first try to get a pixel shader that multiplies two textures\par
then try to get one that multiplies a 2D by a 1D\par
then use the FFT source data as the 1D, and a rainbow gradient as the 2D\par
then do a radial version then a mirror-reflected version\par
\b\par
\par
 - time offset adjustment\par
 - loopie cloning (with refcounting on underlying streams?)\par
\b0   \par
  \par
 DURING-ALPHA FEATURES by priority:\par
 - double arms extended (conductor gesture) just for volume control over everything\par
 - animated menus\par
 - time reversal\b\par
\b0  - group select (double point)\par
 - more built-in sound effects\par
 - animated sound effects (grab to choose effect, then point again to record animated envelope; open hand to end envelope)\par
 - visual effects for each sound effect\par
 - more visual effects generally (e.g. edge filter for simpler person display)\par
 - group downmixing?!\par
 - skeleton recording and animated display\par
 - IR recording\par
 - hierarchical popup menus\par
 - grid-based slicer\par
 - Turnado program selection\par
 - preset building (with speech recognition naming?!?!?!)\par
\par
\b\par
HOLOFUNK PRESENTATION NOTES\par
\b0 Holofunk is a four-dimensional mirror reflecting slices of the past.\par
\par
\b\par
\par
K4W2DOs:\par
\b0 - why no Count member of EVERY ENUM in the SDK? (e.g. HandState)\par
\par
\b\par
\b0 - sliiiiiides, baby\par
\par
\par
\b\par
\b0 because would be really great to be able to record snippets, for debugging, gesture training, testing without attached hardware, etc.\par
\par
\par
\par
- Prevent offscreen tracks, clamp to within some boundary of edge\par
\par
- Find proper 120BPM Turnado clocking (did I have the saved preset files in the right place?)\par
- Make 80BPM clocking as well\par
- Switch tempo by changeable menu item that is only available with no tracks\par
\tab - ditch the old way\par
\par
\par
\par
\b LOOPIE GROUPING\par
\b0 figure out exactly how it should work.\par
- within minimum radius of existing loopies causes it to "stick" with certain degree of springiness\par
\tab - also forms into reasonably nice circle?  to prevent hopeless amorphousness?\par
\tab - give credit to Nick Wichman for this one\par
- maybe draw circle around entire group?\par
- instantly inherit duration of group\par
\tab (if you go longer, the existing loops keep their duration of course but new loops get the longest)\par
\tab (provisional decision, there, but worth a try)\par
\tab NO NO NO, HORRIBLE IDEA\par
\par
\par
Program selection done with multilevel popup menu, but only once we have mixdown (so we don't have N layers of VSTs and so we get sample-accurate recording).  Hmm, that means that the effect duration has to be a multiple of the loop duration or get truncated?  Innnteresting.  \par
\par
Maybe need to try out actual dynamic envelopes and see... tricky question... but NOT RELEVANT NOW, JUST TWIST THE KNOBBY-O'S.\par
\par
\par
\par
\par
\par
\par
\par
TIME SPACE:\par
- Look into driving push stream from push stream\par
- Look into data mapping\par
- Play around with lines and setting control points\par
- Drag out a rectangle to create a series of sawteeth\par
- Animated playback\par
\par
- TEST IT\par
\par
SLIDE SPACE:\par
- directory of images\par
- 2 button toggles into slide space\par
- brief press of 2 (<2 beats) goes forward, longer hold of 2 goes back\par
- home returns of course\par
\par
- TEST IT\par
- generalize to random textures / images????\par
\tab - VISUALIZER space?!?!?!  control the (audience?) view more finely?\par
\par
\par
- eight wedges in palette space\par
- select both wedges when over border between them, etc\par
- switch plus to be "toggle mute" rather than "unmute" (except in direct contact?)\par
\par
\par
ADD THREAD ASSERTIONS THROUGHOUT?!\par
\par
\par
\par
\par
\f1 Let\rquote s brainstorm some other spaces.\par
\par
CONDUCTOR space:  while A is down, your hand positions control th volum of each half of your space.  Slightly different than effect space since you are turning the knobs on a spatial region.  Actually it is like a two-handed version of the rectangular parameter space!  But really it is two sliders, one per hand, just for simplicity.  Still you could imagine having the d-pad scroll through presets on each hand independently???  \par
\f0\tab\b CROSSFADE GESTURE\b0  maybe?\f1\par
\par
\f0 MIDIGRID space: yep, like that web toy thing or like a million sequencer pad things.\par
\tab D-pad takes you to different instrument layouts.\par
\par
\f1\par
OK that is enough for tonight.  namaste\par
\par
\f0\par
\par
OK, so we have\par
\par
\tab\tab EffectSpace\par
Midigrid\tab\tab Palette\tab\tab Starfish\f1\par
\f0\tab\tab TimeSpace\par
\par
\par
Palette:\par
\tab Trigger -> PaletteRecording (substate of Recording)\par
\tab Minus, plus -> usual meanings\par
\tab A -> (for now) grab selected loopies and drag them around \tab\par
\tab Up -> go into Effect space\par
\par
Effect:\par
\tab Update: bring up the background (animate it out)\par
\tab\par
\par
AHA, can reuse states already!  Can have \b same\b0  state transitioned to in \b multiple\b0  ways????\par
Hmmm... not quite.  Do we need a way to clone a state?  Yes, let's say we do.  Should be easy.\par
\par
\par
Recording:\par
\tab Update -> reposition loopie to remote hand, maybe pick up duration of closest\par
\tab\tab In effect mode: also apply interpolated effect at current location\par
\tab\tab (what if you go outside the effect box on your side???  while dragging????\par
\tab\tab answer: effect gets clamped but you can put the damn thing where you like)\par
\par
\par
Visual flash:\par
- trail for dragged loopies (in any mode)\par
- ease-in, ease-out for animating transition into effect space / starfish space\par
\par
\par
- quickly test excessively lengthily timed ASIO callback (spike on one and see what happens)\par
\par
\par
\par
\par
- DOCUMENT AND BLOG ABOUT THE CONCURRENCY STYLE\par
\par
\par
EVENTUALLY: minimize-jerk transitions (how to get that right analytically???)\par
\tab short version: velocity along the [0, 1] interval is (vMax * Math.Abs(0.5 - interval))\par
\tab that way it's fastest halfway in between and slows reasonably at the edges\par
\tab but how does it ever get STARTED???\par
\tab fuck it, at first just have a simpler transition function\par
\f1\par
\par
\f0\par
scratching:\par
- generalized mapping of "realtime (X) to loop time (Y)"\par
- draw any structure with exactly one Y value per X coordinate\par
- normal play is 45 degree angle up and to the right; reverse is same rotated 90 degrees\par
- scratching is sine wave, stuttering is sawtooth\par
\par
\par
SYNTHESIZER VST:\par
wooeeeeee!\par
minigame interface like that web toy that has the grid of notes, X is beat, Y is pitch\par
could be AWESOME\par
\par
\par
PHYSICS SPACE\par
literal bouncing loops, spatiolocated\par
squashy / stretchy / sproingy\par
orbiting, rotating\par
\par
\par
- make loopie in hand inherit duration of closest existing loopie\par
\tab - don't mess with drawing just one beat meter (yet)\par
\par
\par
\par
- try 32-bit Perforce on laptop\par
\par
\par
\par
- start researching other maker faires / etc.\par
- come up with other venues for performing with this thing\par
\par
\par
- EXTEND THE ANTS TRIAL\par
- profile in release mode\par
- find out why any Gen2 GCs are happening\par
\par
\par
\par
- research ASIO mixed mode assembly\par
\par
\par
what about pixel shaders for doing the depth buffer -> texture conversion?!!\par
LATER SIR\par
and with TIMINGS!\par
\par
\par
\par
LATER:\par
code coverage\par
\par
\par
Gamasutra(?) latency article:\par
{{\field{\*\fldinst{HYPERLINK http://www.gamasutra.com/view/feature/1942/programming_responsiveness.php }}{\fldrslt{http://www.gamasutra.com/view/feature/1942/programming_responsiveness.php\ul0\cf0}}}}\f0\fs20\par
Make sure my architecture follows known best practices here.\par
\par
\par
\par
\par
\par
\par
\b\fs52 OLD:\fs20\par
\b0\par
\par
SOFTWARE:\par
\par
3DUI for basic graphics / input: {{\field{\*\fldinst{HYPERLINK http://www.bespokesoftware.org/wordpress/?page_id=50 }}{\fldrslt{http://www.bespokesoftware.org/wordpress/?page_id=50\ul0\cf0}}}}\f0\fs20\par
\tab - needs XNA 3.1: {{\field{\*\fldinst{HYPERLINK http://creators.xna.com/en-US/downloads }}{\fldrslt{http://creators.xna.com/en-US/downloads\ul0\cf0}}}}\f0\fs20\par
\par
Bespoke OSC for C# client side: {{\field{\*\fldinst{HYPERLINK http://www.bespokesoftware.org/wordpress/?page_id=69 }}{\fldrslt{http://www.bespokesoftware.org/wordpress/?page_id=69\ul0\cf0}}}}\f0\fs20\par
\par
LiveOSC for Python server side: {{\field{\*\fldinst{HYPERLINK http://livecontrol.q3f.org/ableton-liveapi/liveosc/ }}{\fldrslt{http://livecontrol.q3f.org/ableton-liveapi/liveosc/\ul0\cf0}}}}\f0\fs20\par
\tab - needs Python: {{\field{\*\fldinst{HYPERLINK http://www.python.org/download/releases/2.6.5/ }}{\fldrslt{http://www.python.org/download/releases/2.6.5/\ul0\cf0}}}}\f0\fs20\par
\par
\par
\par
- LiveOSC seems like most direct route into Ableton Live, no need to fuck with Max.  (sigh, wasted $300, oh well)\par
\par
\par
\par
Next:\par
\par
- Install Python.\par
- Install LiveOSC.\par
- See LiveOSC inside Ableton.\par
\par
- Install Bespoke OSC.\par
- Read up on it.\par
- Integrate into HolofunkPrototype.\par
\par
- Fucking try it out!!!\par
\par
- See if can get 360 controller input into BEUI.\par
\par
- Try to make a goddamn button.  Two-way looper toggling with accurate feedback.\par
\par
- Try to track the tempo in Live.  Basic transport control.\par
\par
- Determine how much goddamn allocation this feeb's code is doing.\par
\par
\par
\par
\par
DONEDATE 2011/01/03:\par
\par
- revived EchoFunk, more or less -- dunno why original project biffed, but re-hacking the latest HelloXNAFramework seemed to work\par
\par
- get everything checked into Perforce\par
- aw shit, why doesn't breakpointing work!?  :-P\par
\tab - because I had dragged stale bin/obj dirs over when moving.\par
\tab - rebuilding cleanly fixed it :-)\par
\par
- ensure mike support still works in the thing\par
- it does.  recorded working config in notes.\par
\par
ok, well underway!!!\par
- ControlFrame is a bit wonky\par
- IDrawable converts towards world coordinates (given local transforms from root down).\par
- ITouchable converts towards local coordinates (given world coordinates).\par
\par
Yay, got the beginnings of something!!!!!\par
\par
Finish it up and get multitrack working!!!!!!!!\par
\par
\par
aaah, trust your instincts :-)\par
check out reactive now.\par
\par
ok looks like rx is the shiz alright.\par
there is this XPF thing but it looks semi-stale.\par
and it looks like Rx really wants to be up to date.\par
So just write a tiny little display tree thing in Rx.\par
Should be much nicer.\par
\par
IObservable<IObservable<IDrawable>> for the drawing?!\par
\par
What does declarative time-based animation look like with this?\par
IObservable<HoloTime> is the update stream, right?\par
\par
And yet I want a PULL model for drawing, don't I?\par
...kind of seems like it....\par
\par
Really want reactive to drive the sound AND the graphics.\par
\par
\par
\par
well, it's cool and all.  so yeah, let's do it.\par
BUT, let's FIRST get the current code working just to have a leg to stand on.\par
\par
\par
Definitely need to learn about scene graphs a bit eh what?\par
- Wonder if reactive would really help here.\par
\par
Coordinate<TPosition, TSpace>?!\par
\tab Coordinate<Vector2, WorldSpace>\par
\tab convert to <Vector2, LocalSpace>\par
\tab ack, too distracting!\par
\par
\par
\tab - got the linkies\par
\par
- what orientation does this app WANT to use?\par
\tab - start with tuning for vertical\par
\par
brainstormy:\par
\par
IObservable<IObservable<IDrawable>> for the rendering.\par
This ticks on the drawing clock.\par
\par
Behavior<HoloTime> for the current time???\par
Yes yes yes.  That is availble to whoever wants it.\par
\par
No, it can't be IDrawable since that is not side-effectable.\par
And it can't be pure functional since the allocation will kill me.\par
\par
Perhaps it can be TSprite?\par
\tab - reuse/pool instances?\par
\tab - entirely prompt?\par
\par
So what would happen would be:\par
- there's an IObservable<Unit> for the draw tick\par
- you want to write this as:\par
\par
IObservable<Primitive> \par
\tab - pushes out all the primitives.\par
\par
what about time???  you just get the current time from the BehaviorSubject?\par
GAH.  what I WANT is to say that the drawing primitive is a function of the last time.\par
but the update time is decoupled from the drawing time.\par
WHY do I care about the update time?\par
Let's say it's JUST a graphics app for the moment.\par
\par
Then in that case it's an IObservable<HoloTime>.\par
\par
Well, that's all very well, but really the problem is that we want to be producing an IObservable<SceneGraph>.  But that's way too much garbage to literally do.\par
\par
Perhaps learn a bit more about ITBs?  Or would that be too risky....\par
\par
\par
...sigh, that was one big ol' detour into the arrghatron.\par
\par
OK, I have it kind of compiling now but it is all kind of dismembered.\par
But this is exactly what this WHOLE EXERCISE IS FOR....\par
\par
- Efficient drawing requires NOT using some kind of bogus object pooling thing.\par
\tab - HAS to be a visitor/sink-method paradigm.\par
\tab - So, let's say that each drawable maintains a view matrix.\par
\tab\tab - Relative to parent only?\par
\tab - Stack of view matrices.  Allows local changes as you visit.\par
\tab\tab - Standard scene graph; do some quickie research in available 3D gfx texts.\par
\par
- Sink has methods for drawing textures (only, at the moment).\par
- Visit propagates the current view matrix (stack?).\par
\tab - Grouping nodes push and modify a new matrix, then pop.\par
\tab - Right, right, this is all standard stuff.\par
\par
- INPUT handling ALSO goes via visit!\par
\tab - transforming the world coordinates to local at each step!\par
\tab - (xen codeplex project not gonna work because no input handling)\par
\par
- Overall animation paradigm:\par
\tab - composable in scene graph\par
\tab\i - HoloTime is passed down in visit\par
\i0\tab - can be used to tweak colors, etc.\par
\par
Yes yes, this is all fine, and MUCH more efficient than Rx.  Again, don't use list enumeration when what you want are prompt tree traversals with no data motion!\par
\par
Alright.  So we may still be able to use Rx for all the plumbing of events at the app level...?  yes very possible, but it will just be bottoming out at particular subscribees (loopies, etc.).\par
\par
And the update timer can certainly be a plain IObservable<HoloTime>.\par
\par
(Would be nice if the sound effects could be handled with Rx....)\par
\par
- but actually let's try doing it all WITHOUT Rx at first, then refactoring it.\par
\par
- So in that case what we really want is for the Loop update to manually and imperatively track its playing end time, and restart the loop right then.\par
\par
\par
...no, we can use reactive for things dealing with \i time.\i0\par
but we'll have a prompt sink-based scene graph for \i space.\i0\par
...no, I don't like that idea much either.  QUICK WRITE TO ROY\par
\par
\par
ok done.  So let's draw some pictures.  A prompt tree:  the scene graph.  Traversed on every Draw call; pass down the current time.  Do math based on the current time, update parameters, etc.  Would be nice to control all the time-varying parameters with reactive...?  But then how does that state get persisted for the draw stage?  Aah it shouldn't even matter, should it?\par
\par
Yes, it DOES matter.  OK.  VISUAL things should get done in the draw loop.  \par
Reactive animation?  Are people actually using Rx for graphics?  Sure they are, obviously.  Let's look at that guy's example again.\par
\par
ALright, the separation is *this*:\par
- Reactive drives all time-based state change.\par
- Simple reactive formulas produce time-based derived events that affect state.\par
- The state ultimately is expressed as observables consumed by observers that snapshot it into the scene graph.\par
- So the scene graph is a static portrayal of the state as of the last instant.\par
\par
IObservable<Beat> derives from IObservable<GameTime>.  NICE\par
\par
- Input.  What about input?\par
- Need to transform it down the scene graph, no?\par
\tab - Well, it's really a spatial query.\par
\tab - All good scene graphs support hit testing.\par
\par
Can we write the input-driven transitions easily with Rx?\par
\par
What is the model for sound?  You want to express the \i individual\i0  sound-on / sound-off / record / etc. transitions as observable events.\par
\par
So let's say that you have an IObservable<TouchLocation>.\par
The scene graph observes this and translates it to buttons.\par
Each button has its own IObservable<TouchLocationState>.\par
It doesn't NEED to know what time it is.  \par
The Loopie observes the button's touches.\par
\par
How does state switching work in Rx?\par
It's a simple select, isn't it?\par
But on what?  Do you get to retain YOUR current state?  How?\par
\par
OK fuck it, let's make the Loopies into subjects.  I will learn better someday but not yet.\par
\par
\b So what IS our desired interaction?\par
\b0\par
- Touch a button.\par
- IObservable<TouchLocation> fires to scene graph observer.\par
- Scene graph hit tests its way down to a specific button.\par
- Fires the button's IObservable<TouchLocationState>.\par
- Button fires IObservable<ButtonPress>.\par
- Loopie monitors ButtonPress as a subject.\par
\tab - Subject has state machine.  Good ol' prompt imperative state machine.\par
\par
\par
THE STATE MACHINE:\par
...is beautiful!\par
\par
\par
\par
OK, so we are going to combine three major abstractions:\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li720 A prompt tree-based 2D scene graph.\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li1080 Each node has a world-to-local transform.\par
{\pntext\f9\'B7\tab}The entire state is fully static and promptly renderable.\par
{\pntext\f9\'B7\tab}Conceptually the Draw method DOES NOT PASS THE TIME.\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li1440 All Draw state is promptly available.\par
{\pntext\f9\'B7\tab}Computation per se does NOT happen in scene graph traversal.\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li720 A hierarchical state machine.\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li1080 entry and exit actions\par
{\pntext\f9\'B7\tab}nested states\par
{\pntext\f9\'B7\tab}transitions crossing boundaries and routing properly\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li720 A reactive event flow for time and input.\par

\pard{\pntext\f9\'B7\tab}{\*\pn\pnlvlblt\pnf9\pnindent0{\pntxtb\'B7}}\fi-360\li1080 Beats derived from time.\par
{\pntext\f9\'B7\tab}Update method fires time updates.\par
{\pntext\f9\'B7\tab}Also fires input updates.\par
{\pntext\f9\'B7\tab}Input routed promptly through scene graph.\par
{\pntext\f9\'B7\tab}Controls observe an IObservable<Touch>.\par
{\pntext\f9\'B7\tab}They publish an IObservable<ButtonPress>.\par

\pard\par
Then:\par
- Loopies are state machines.\par
- They expose controls.\par
- The game wires the loopie controls together with parent scene graph nodes.\par
- The game sets up the basic reactive plumbing.\par
- The loopie state machines are driven by observing the controls.\par
- The loop has its OWN state machine driven by the passage of time!  (TBD)\par
- The control images are driven by the loopie state machine.\par
- A general message bus works for global messages, with source filtering to avoid loops.\par
\par
\b FUCKING FANTASTIC!!!!!\b0\par
\par
AND AND AND, it SHOULD be... should it???... it SHOULD be completely drivable from the event log!!!!!\par
\par
should be able to record the whole event log and play it back deterministically.\par
along with the sounds recorded.\par
you can record the whole session AND JUMP IN ANYTIME?!?!?!\par
... yes, with appropriate broadcast event firewalling.....\par
... hmm, not quite, it's like trying to play a player piano :-D\par
\tab - would have to abstract it at the level of the... what?  button press events?\par
\tab - no, they're not button press events, they're COMMANDS.\par
\tab - and they get assigned to buttons by OBSERVABLES.\par
\tab - and they don't glitch because it all happens between renders.\par
\par
holy crap that's awesome?!\par
\par
wow, it really IS awesome!!!!!!!\par
\par
it all hangs together beautifully.  and NOW it makes sense and I can build it.  and I know it will extend marvelously.\par
\par
FUCK YEAH\par
\par
ok enough for tonight!\par
\par
- good perf data, but RUH ROH:\par

\pard\sb100\sa100\f2\fs24 Applications should not exceed 90 MB of memory usage unless Windows Phone has more than 256 MB of physical RAM\par

\pard\f0\fs20\par
ok, getting hung up on details of polymorphism in the state machine actions.\par
what exactly does this observer code look like?\par
EACH TRANSITION *IS* AN OBSERVER?!\par
and they come and go as you enter and leave?\par
\par
wow this seems like it would create A LOT of garbage.  so don't want that.\par
DO want some mapping from observer to transition invocation.\par
but WHAT exactly?  \par
well DUH it's an observation of some kind of event namespace that is meaningful to the state machine.\par
So specifically it is TEvent and the state machine implements IObserver<TEvent>.\par
AND the state machine IS stateful... the static initialization is where the subclass customization comes in.  But it ONLY contains the current state and the current TActionState.\par
\par
ok I think I like that.\par
\par
but WHERE THE FUCK IS IOBSERVER<T>?!?!?!?!  something fubar here\par
... gah, System.Observable has to be added separately.  trivial.\par
\par
\par
\par
OK, have to time out now. \par
- finish StateMachine constructor\par
\tab - should take list of states, initial state, and list of transitions\par
\tab - transitions are Tuple<TState, TEvent, TState>\par
\tab - transitions are taken when OnNext(TEvent) matches a tag\par
\par
\par
DONEDATE 2011/03/08:\par
\par
aah fuck.  TEvent as written is essentially stateless.\par
... why?  In fact it could trivially contain a sender reference, and standard IEvent probably does!\par
... so maybe use that after all.\par
\par
ok sleep\par
\par
\par
\par
Erik Meijer suggestions:\par
- have a stateful SelectMany that keeps the state\par
- have a join that observes its own output\par
\par
\b NEXT TIME:\par
- finish StateMachineInstance - DONE!\par
- write tests and tinky test harness - DONE!\b0\par
\par
ok, I have the classes stubbed out :-D\par
BUT what is the relationship between these classes and animation???\par
\par
Let's not EVEN worry about it yet.  Let's treat animation as solely the result of feeding updates to local transforms via some extrinsic mechanism.  The scene graph is \i purely prompt and instantaneous\i0  -- it has \i no notion of time whatsoever.\i0\par
\par
STICK TO THAT INVARIANT.  \par
\par
OK fine, but then we DO need to figure out how we get tweening, e.g. let's suppose they rotate their phone and we want to tween the transition to the new layout... we conceptually want the scene hierarchy to handle the transformation in some reasonable way, but what???  In other words, on the one hand we don't want the scene hierarchy to understand time or animation (for sanity's and clarity's sake), but on the other hand we want to be able to animate the hierarchy sensibly (for lack of duplication's sake).  TBD what we do about this.  For now, we support only one layout anyway....\par
\par
\par
GAH, so many distractions -- what about coordinate space as a (hidden) type parameter???\par
- analogous to units in some sense since getting it wrong is equally problematic.\par
- but encoding coordinate space as a hierarchy = dependent typing...?!  glah\par
- FORGET IT!\par
\par
\b - lift test classes out into real locations (retain testability) - DONE\b0\par
\par
\b - start building scene graph\b0\par
\par
\par
WorldBoundingBox issues:\par
- may want to be lazy in updating this.  in fact going down exactly that path.\par
\par
MUCH FOOFARAW about exactly how parents transform their children.\par
converging now on design where the parent keeps a per-child Transform explicitly.\par
this avoids child state that is managed by the parent (always confusing),\par
without requiring an explicit TransformNode concept that looks like a weird kind of single-child-only AParentSceneNode.  In practice any worthwhile parent node is going to want to move its children in a way it controls, so let's set it up to do just that.\par
\par
Child nodes then need a way to get their individual local-to-world transforms, without some kind of hideous "m_childList.IndexOf(this)" O(N) nightmare.  So when you attach them to a parent, have the parent give them back a Func<Matrix> they can use to get their own xform.  Nice functional encapsulation!\par
\par
\b NEXT TIME:\par
\b0\par
\b - finish the scene graph implementation\par
\par
\b0 Hmm.  So in thinking about the use case of a tray node laying out animating buttons, it seems the button may want to present a different LocalBoundingBox to its parent than it actually uses for rendering.  If you want to have buttons pulsing gently within a tray, without affecting their peer buttons, then the LocalBoundingBox each button exposes to the parent needs to be stable.  Therefore the button needs TWO local transforms -- one that it exposes to the parent, and one that it applies locally when rendering.  OK, fine.\par
\par
But do ALL nodes need this?  Possibly, possibly.  OK, let's make it universal.\par
\b\par
\par
- get a-testin'\b0\par
\par
\par
\par
\b - immutable representation of entire performance\par
\tab - can transform any interval into sound buffer\par
\tab - supporting efficient recording into live performance\par
\tab - efficient transclusion!\par
\tab - all transitions driven off of samples\par
\tab - tracks all existing for whole performance\par
\par
\b0 some kind of visibility metaphor?\par
- and audio and video both derived!\par
- what about grouping?  do we want to capture full all-time animation?\par
\tab - yes, yes we do!  would like to have everything!\par
\tab - it's necessary anyway for getting an envelope out of a gesture!\par
\tab - wow, that's bizarre.\par
\par
so let's view the performance and the microphone both as input vectors that exist for the whole performance, continuously and UNCONDITIONALLY recorded!\par
\par
what do we CALL this thing???  track?  tracks have subtracks?\par
rather like a temporal scene graph!  Open-ended interval concept!\par
ok let's just call it a track for now.\par
\par
DataTrack is a source of samples.  Parameterized by sample type?!  hmm interesting.\par
Hand position generates DataTrack<Vector3>; sound channel generates DataTrack<float>.\par
(how is stereo represented in ASIO?)\par
\par
DataTrack can be relayed right to Channel.  Relayed HOW?  Well, it could just be smashed in there if all you have is effectively mono.  Or, it could be pulled to a StereoTrack that takes a DataTrack<SoundSample> (defaults to float?!) and a DataTrack<float> for the L-R position, and emits two DataTrack<SoundSample>s.  FUCK YES.\par
\par
Multiple outputs, how to do it with IObservable?\par
And the issue here is that this is not really simply IObservable because it is all time correlated and has to move in lockstep.\par
So think of it more like a reactive computation.  Pull-driven, perhaps even!\par
Track<TValue>'s fundamental API:\par
\tab - Buffer<TValue> Compute(Interval interval)\par
\par
Interval: Time start, Time end\par
Time: int Ticks, bool -Infinity, bool +Infinity\par
\tab - or just use float inf?\par
\tab - yes, let's try that.\par
\par
hmm, is it Buffer<TValue> or isn't it?\par
\tab - pull is nicer in this case because it enables traversal from the sink.\par
\tab - but how do you pass up the context you need to render the audio into?\par
\tab - and how do you avoid redundant computation?  (e.g. stereo channel with even balance)\par
\par
general problem with an observable network....\par
\par
DataTracks can be sources AND sinks!\line Implement intermediate caches that way!\par
\par
\par
And if you have a DataTrack whose capacity is limited then you have intermediate buffers without unbounded space requirements?!\par
\par
No, probably better to make it an explicit TemporaryTrack or something, to clearly indicate that it is ephemeral from the overall model's point of view.  But the point is that it can be injected into the graph and later elided without affecting the rendered sound.  The goal here is to make it trivial to describe the transformation pipeline in an immutable way, allowing the description itself to be shared piecewise, wihch provides all sorts of nice cloning behavior.\par
\par
So let's call it TemporaryTrack.  \par
\par
Track<TValue> = function from Interval to Buffer<TValue>.\par
SampleTrack<TValue> = source of samples.  \par
TemporaryTrack<TValue> = intermediate bounded buffer, source and sink.  \par
StereoTrack<TSound> = function from Track<TSound>, Track<float> to Track<TSound>, Track<TSound>.\par
SineWaveTrack : Track<NegOneToPosOne> = simple sine wave generator.\par
LoopTrack<TValue> = looper of some Interval of an underlying Track.\par
\par
Can trivially create\par
\tab SineWaveTrack -> TemporaryTrack -> LoopTrack\par
and get a one-second sine wave loop for the cost of a single second's buffer and zero runtime computational overhead after the first second.\par
\par
Track<TValue> implements Compute(Interval interval, ref Buffer<TValue> outBuffer)\par
where outBuffer is what gets written into.\par
But what about multiple outputs?  e.g. StereoTrack?\par
Compute1, Compute2?\par
DoubleTrack<TValue>?\par
MultiTrack<TValue> implements Compute(Interval interval, int trackIndex, ref Buffer<TValue> outBuffer>)?\par
\par
Yes, I think I LIKE IT.\par
\par
So you always pull, and you use TemporaryTracks to achieve intermediate buffering.  BEAUTIFUL.\par
\par
Then you get a number of things for free:\par
- full static description of the whole performance\par
- full recording of the whole performance\par
- easy composability of new Track types\par
\par
GOD IT'S LOVELY!\par
\par
Then a Loopie is what, exactly?\par
- a user interface widget that supports modifying a set of Tracks.\par
\par
The spatial position of a Loopie is \i itself\i0  a Track<float>.\par
Support SparseTrack<TValue> that just contains a set of discrete signal changes.\par
\par
Actually Signal is good too.  Signal or Track?  hmmmmm, very tricky.  I think Signal is more general, though, and more clearly connotes FRP.  So let's roll with it.\par
\par
Output is the ultimate sink, the thing that calls Compute on the upstream Signal(s).\par
\par
So a Loopie controls a couple of Signals:\par
- the SparseSignal<Vector3> Position of the Loopie (need some good representation that handles dense sampling when desired... something like a SharedSignal that is a sparse Interval -> Signal mapping, where the Signal can be reassigned perhaps arbitrarily, or even computed?!)\par
- the Signal graph that represents the constructed sounds of the Loopie\par
\par
How do we mutate that Signal graph given our immutable representation?  Well, we add new Signals that have a start interval that excludes everything that already happened!  Very much a temporal database problem -- we leave history alone, but add new "layers" that are simply "transparent" everywhere prior to now.  "Deleting" sounds is done by setting them to invisible from now on, which also allows them to be revived.  "Audibility caching" supports efficient update in the presence of possibly many inaudible Signals.  \b BEAUTIFUL.\b0\par
\par
OK, that's enough brilliance for tonight :-D\par
\par
\par
NO IT ISN'T!  So this whole design is working, because it highlighted the issue of how does the continuously live microphone work?  How does the SampledSignal from the microphone become the StereoOutput?  Answer:  there is always some effect in place on the microphone itself, and in fact \i the microphone itself is a Loopie.\i0   It exists in space and a user "start/end record" causes it to bud a new LoopSignal adjacent in space.  Transforming the Microphone results in LoopSignals that are equally transformed.  FUCKING AWESOME.\par
\par
Meanwhile on the render level, operations such as pitch control, volume control, balance, etc. are all visually represented on top of some kind of underlying frequency view.  Bidirectional hourglass mixer view.  But that's monochrome -- what did Arlie want to use color for again?  Need to ask him.....\par
\par
\par
\par
\b - build IObservable<LoopieButtonType> for the buttons\par
\b0\par
\par
\b OVERALL PLAN:\par
- build mini scene graph\par
- build toy app that reacts to clicks by changing buttons\par
\par
- build Loop that represents sound\par
- build Recorder that buffers microphone and produces Loops\par
- build Sound Recorder\par
\par
- build proper Loop app\par
\b0\par
- \b add beats (background metronome, sound only)\b0\par
\b - add visual beat feedback \par
\b0\par
- \b modify Recorder to be beat-aware\par
- add beat cues to Recorder buttons\par
\par
\b0\par
\par
RECORDER:\par
- single object keeping the whole stream.\par
- it spits out buffers that get picked up.\par
- not only buffers but buffer slices.\par
\par
\par
I want something containing all the Loops.\par
Arrangement?!  Yeah why not.\par
\par
So the Arrangement contains loops.\par
\tab Loops have duration in number of measures.\par
\tab Do loops have an offset from beat zero?!  Yes they must.\par
\par
How do we precisely know when to start and stop?\par
If you start and end exactly on the beat, then you am happy.\par
But you never can.  So if you start just BEFORE the beat, then the time offset\par
would be a bit negative; after, a bit positive.  And if you go just a little long but then let up (say, within 1/2 a beat), that tail gets truncated where it overlaps.\par
\par
What if you do an odd number of beats?  All kinds of modes possible; let's say at first it's multiples of two, and minimum of one.\par
\par
\par
The Arrangement also contains effects.\par
Some kind of separate thread for effects?\par
How does realtime playback work?  Can you play back while you're recording?  How?  What about realtime effects?\par
\par
\par
\par
MINI EXPERIMENTS:\par
- realtime effects (measure latency!)\par
- garbage consumption to GC count\par
- duration and frequency of GCs\par
\par
\par
You need to be able to handle clock skew.\par
At any given moment you may need to service a buffer end event.\par
When you get one, do you know the time???\par
\par
\par
Things currently pondering:\par
- interaction of buffer end events, update events, and general time management\par
- recording while simultaneously playing back (with effects?!)\par
\tab - end-to-end recording->playback latency\par
\par
\par
Basically need some kind of picture of what's happening on a per-loop basis.  If your clock skips, you have to get back on track ASAP.  Can use realtime to resync, so you may pop but you don't skip.\par
\par
SUBMIT DATA IN 100 MS CHUNKS\par
STAY TWO BUFFERS AHEAD\par
\par
wonder how much smaller we can chop it?\par
\line DynamicSoundEffectInstance seems perfectly groovy.\par
yes it indeed is, you can submit chunks of buffers, it's perfect.\par
\par
So the Recorder produces a stream of BufferSlices.\par
The Recorder can be configured to feed into a Loop.\par
The Loop absorbs the BufferSlices internally.\par
\par
Can't play absolutely in sync -- the recording buffer has to be at least 100ms long.  But can you get incremental data out of it?!  Racing against the recorder?!?!?  Glark, that seems crazy to do.  Besides, you have to copy data from it....\par
\par
Want my own stream class that exposes the underlying BufferSlices.  BufferStream, natch.\par
Then we should have sub-Streams because there is one true big one for the Recorder, and the sub-streams slice it up!!!\par
Then loops hold substreams and manage interaction with a DynamicSoundEffectInstance.\par
... or do they?  \par
\par
THE ARRANGEMENT CONSISTS OF THE SUBSTREAM COLLECTION.\par
It is static.\par
The Game (sigh, copout) is responsible for creating whatever it is that keeps the substreams playing.\par
And just what IS that?!\par
\par
Well, here are the state transitions we need to consider:\par
\par
- Loading an arrangement and starting playback of the entire thing.\par
- Adding a new loop that is being recorded.\par
- Transitioning a recording loop to playing.\par
- Muting an individual loop.\par
\par
\par
But it's not just muting, it's arbitrary parameter manipulation.  Which raises the meta-question:  when are you adjusting a parameter permanently (e.g. fading out a sound progressively over multiple loops), and when are you recording a \i parameter loop\i0  (which may or may not have the same duration as the loop itself)?????\par
\par
How do you select whether to record parameter changes?\par
\par
On the phone, I think what you do is swipe to pick the effect.\par
\tab Then the phone has an overlay in action.\par
\tab MULTITOUCH to record!!!  Some kind of area at the bottom or wherever, or lower-left/lower-right red circular REC buttons.  So you pick your effect, scrub like crazy with right thumb and pinch with left thumb, and Bob's your uncle, you have a parameter effect.\par
\par
Parameter effects have to get applied on the same 100Hz clock.  (and recorded at that tempo, too!)\par
\par
(what about filtering / time-lag?  what is average update clock jitter?  enh, don't worry so fuckin' much already)\par
\par
All THAT really DOES want Rx in place, just to avoid callback hell.\par
\par
\par
So let's say there is the Observable Pipeline.\par
IObservable<HoloTime> Update \{ get; \}\par
\par
(HoloTime is since the beginning of the app.)\par
\par
IObservable<BeatFraction> Update.Select(time => time mod beat_duration);\par
\par
IObservable<BufferEnd> applied to the TrackPlayer.\par
\tab Player is active object coordinating the event pipelines around that Track.\par
\par
Player has assignable IObservable properties for each key parameter.\par
Live input maps the central touch position to some quantitative IObservable space.\par
Rx magic then maps that to a normalized coordinate system, and then to whatever parameter is desired.\par
This can directly drive the TrackPlayer's parameters in realtime.  It can also feed into a BufferStream via a BufferParameterObserver.  Then that BufferStream can become part of the Arrangement, indexed against that parameter, and an observer is set up on \i that\i0  which handles parameter update.\par
\par
So the Arrangement contains Tracks, and each Track contains an audio BufferStream and one or more parameter values-or-BufferStreams.\par
\par
State changes in the contents of the Arrangement trigger Rx event pipeline manipulation.\par
But during actual playing, and even during some recording scenarios, Rx is pumping everything and no other relevant states are changing.\par
\par
OK I THINK I LIKES IT V. MUCHESTEREST\par
\par
So the Arrangement is PURE DATA all the way down (including all Tracks, modulo recording into them), and we have behavioral objects on top, TrackPlayer, Recorder, Loopie.\par
\par
ALRIGHTY THEN!!!  I can handles thats!\par
\par
So let's see.  16000 samples/sec x 2 bytes / sample = 32K / sec.  1M / 32K = 32 seconds per megabyte.  90 megabytes x 32 seconds = 2880 seconds.  2880 seconds / 60 = 44.5 minutes.  OK, that makes sense.\par
\par
But if we have the sub-BufferStreams keep their own buffers, and if we drop them when we record over them etc., then we should be able to recycle them appropriately.  Should have IDisposable on the BufferStreams....\par
\par
So we can do plenty with this!!!  Could have ten one-minute loops and only burn a quarter of the memory, and it won't be nearly that much in practice.  Great!  (Even if actual phone has 3x the sample rate, we would still be fine....)\par
\par
FINE fine \b FINE!!!\b0\par
\par
\par
\b NEXT: START HACKING, DUDE!  \b0 And find out whether buffer end events have timestamps, or GameTimes....\par
\par
So how much lag time do we want?  e.g. how do we manage the buffer queue-ahead?\par
\par
When playback starts:\par
\tab - calculate the position of the current time in the current track\par
\tab - queue up two buffers ahead\par
\par
Who fucking knows whether List.Clear() keeps the backing store?\par
Have to write a stress test of it and see how many GCs happen :-P\par
\par
no one gives a shit about unit testing, fine, will just roll my own.\par
\par
- get tiny app onto phone?\par
\tab - how does real phone deployment work?\par
\tab - might as well try it out first :-)\par
\par
\par
DONEDATE 2011/05/11:\par
\par
OK, let's collect all the surfing I did before, and download stuff as peers of Holofunk.\par
\par
WiiMoteLib:\par
{{\field{\*\fldinst{HYPERLINK http://www.brianpeek.com/blog/pages/wiimotelib.aspx }}{\fldrslt{http://www.brianpeek.com/blog/pages/wiimotelib.aspx\ul0\cf0}}}}\f0\fs20\par
How-to article:\par
{{\field{\*\fldinst{HYPERLINK http://channel9.msdn.com/coding4fun/articles/Managed-Library-for-Nintendos-Wiimote }}{\fldrslt{http://channel9.msdn.com/coding4fun/articles/Managed-Library-for-Nintendos-Wiimote\ul0\cf0}}}}\f0\fs20\par
\par
NAudio:\par
{{\field{\*\fldinst{HYPERLINK http://naudio.codeplex.com/ }}{\fldrslt{http://naudio.codeplex.com/\ul0\cf0}}}}\f0\fs20\par
\par
SkypeFX voice changer example NAudio app:\par
{{\field{\*\fldinst{HYPERLINK http://skypefx.codeplex.com/ }}{\fldrslt{http://skypefx.codeplex.com/\ul0\cf0}}}}\f0\fs20\par
\par
Math.NET Numerics:\par
{{\field{\*\fldinst{HYPERLINK http://numerics.mathdotnet.com/ }}{\fldrslt{http://numerics.mathdotnet.com/\ul0\cf0}}}}\f0\fs20\par
\par
ASIO.NET:\par
{{\field{\*\fldinst{HYPERLINK http://www.codeproject.com/KB/audio-video/Asio_Net.aspx }}{\fldrslt{http://www.codeproject.com/KB/audio-video/Asio_Net.aspx\ul0\cf0}}}}\f0\fs20\par
\par
ASIO SDK:\par
{{\field{\*\fldinst{HYPERLINK http://www.steinberg.net/nc/en/company/developer/sdk_download_portal/asio_sdk.html }}{\fldrslt{http://www.steinberg.net/nc/en/company/developer/sdk_download_portal/asio_sdk.html\ul0\cf0}}}}\f0\fs20\par
-- MUST HAVE 3RD PARTY DEVELOPER ACCOUNT!\par
{{\field{\*\fldinst{HYPERLINK http://www.steinberg.net/en/company/developer.html }}{\fldrslt{http://www.steinberg.net/en/company/developer.html\ul0\cf0}}}}\f0\fs20  and READ WHAT IT FRICKIN' SAYS, DUUUUUH\par
\par
PD core link:\par
{{\field{\*\fldinst{HYPERLINK http://crca.ucsd.edu/~msp/software.html }}{\fldrslt{http://crca.ucsd.edu/~msp/software.html\ul0\cf0}}}}\f0\fs20\par
\par
Yvan Grabit ASIO SDK community page:\par
{{\field{\*\fldinst{HYPERLINK http://ygrabit.steinberg.de/~ygrabit/public_html/index.html }}{\fldrslt{http://ygrabit.steinberg.de/~ygrabit/public_html/index.html\ul0\cf0}}}}\f0\fs20\par
\par
\par
...Got everything pulled into Holofunky, a new Windows Game 4.0 project.  But why only x86???  Oh well, not really an issue for this project.\par
\par
...Reading ASIO SDK docs, or skimming at least.\par
\par
Build ASIO.NET test example in new standalone VS2010 project.\par
Run ASIO.NET test example.\par
\par
Pull ASIO.NET library into mine.\par
Get it building.\par
\par
ASIO4ALL:\par
{{\field{\*\fldinst{HYPERLINK http://www.asio4all.com/ }}{\fldrslt{http://www.asio4all.com/\ul0\cf0}}}}\f0\fs20\par
\par
- install final VS2010 on home machine.\par
\tab - how to get from laptop???\par
\par
- resolve frickin' COM error\par
- try removing [STAApartment] (or whatever) in ASIO.NET test sample\par
\tab - see if it breaks\par
- try \i adding\i0  that to Holofunk\par
\tab - see if IT breaks\par
- FUCK ASIO.NET, BASS IS THE WIN.\par
\par
\par
YAYYYYY actually got bassasio full duplex to work in the context of Holofunky!\par
and with that, that's enough for tonight :-D\par
\par
ALRIGHTY THEN, got the previous StateMachine test revived.\par
that is VERY NICE.  baselined.\par
\par
what first?\par
\par
without some kind of UI it'll be damn hard to make any progress.\par
\par
so let's figure that out.  what kind of UI can I do with mouse?\par
\par
- red blob in the middle\par
- hold to get copy blob that records\par
- release to let blob float free in its current direction until far enough\par
\par
ok fine.  so to make this happen, need scene graph booted up.\par
and input state machine.\par
\par
2D is still fine though.\par
make them fuckin' rectangles already!\par
\par
don't need tray at all.  but don't screw with it\par
how much testing do I need???  100%!!!!!!  feh.  but can run code coverage? \par
\par
OK FINE LET'S GET THE BLOBS FLOATING AND CLICKING FIRST.\par
\tab and spamming\par
\par
\par
so the state machine for the recording blob is:\par
\par
- pulse gently (always)\par
- mouse down: spawn new blob centered on mouse location, closer to viewpoint in Z-order\par
\par
state machine for the separate blobs are:\par
\par
- pulse with music\par
  \tab - aaah, don't want to spend too much time on crappy mouse interface\par
\par
Wiimote interface:\par
- trigger = record current gestures into selected\par
- A = change selected\par
- D-pad = effects on selected\par
Mouse interface:\par
- left button = record current gestures into selected / MAKE current gestures\par
- right button = change selected\par
\par
aah, mouse one sucks.  don't sweat it, it's not THE POINT.\par
anyway will be enough to record multi tracks and dick with beat matching.\par
\par
then can start going nuts:\par
\tab - screen quadrants\par
\tab - widgets in screen corners for group sound manipulation\par
\tab - popup widget menu when right-clicking, for sound manipulation\par
\par
so hit testing needs to be pixel-accurate?  FUCK ME how is that gonna work?\par
\tab - separate texture for hit testing?\par
\tab - or just Z- sorted rectangles / circles?\par
\tab - let's say it's the latter for starters, do it analytically; much simpler\par
\par
how do you draw a nice circle anyway?\par
depends on how you want to do it, dunnit?\par
should be able to make a nice geometry list and instance the fuck out of it....?\par
solid / gouraud shading?\par
or a fine bunch of concentric geometric circles, fine enough to change the color really nicely and quickly?\par
have to experiment.\par
\par
- get Wiimote playing with XNA - \b DONE\par
\par
- \b0 get basic Kinect wrapper compiling - \b DONE\b0\par
\par
\tab - what does XNA use for color? - Color, duh!\par
\par
\tab - doesn't seem to be any 2D drawing API in XNA\par
\tab\tab - line strips and lists uber alles\par
\par
\tab - System.Windows.Media.PixelFormats.Bgr32 seems not to be a native XNA format :-(\par
\par
\tab - but Microsoft.Xna.Framework.Graphics.SurfaceFormat.Color is fine\par
\tab\tab - just have to swizzle differently when parsing the depth image.\par
\par
- create synthetic Color texture - \b DONE\b0\par
\par
- get Kinect wrapper to create RGB32 textures (stupidly) - \b DONE\b0\par
\par
- get Kinect depth image as XNA texture in scene graph - \b DONE\b0\par
\par
- get Kinect wrapper to create skeleton normalized to camera extent - \b DONE\b0\par
\par
- get Kinect skeleton as... WHAT??? in scene graph - \b DONE\b0\par
\par
- figure out how to represent UI-relevant skeleton state - \b DONE\b0\par
\par
- add colored triangle on one hand - \b DONE\b0\par
\par
- change to hollow alpha circles on \i each\i0  hand - \b DONE \b0 (have to begin/end per sprite!)\par
\par
- get some alpha-capable art program - \b DONE\b0\par
\par
\par
\par
DONEDATE 2011/08/18:\par
\par
GENERAL BASSASIO NOTES:\par
\par
- SimpleAsioFX sample shows ASIO callback doing its own level processing.\par
\tab - Does not show capturing to a memory stream.\par
\tab - Does seem to show pitch adjustment!  hmmm!\par
\par
- Float buffers are the way to go, they work with ASIO and with DX8 effects.\par
\par
BASS_ChannelGetData has some bizarre "length or flags" argument that seems to make it... trivial???... to get FFT representations of data!  WHOA....\par
\par
OK now the key question is, how exactly do I handle an ASIO recording stream buffering to memory???  \par
- what are the rules for the ASIO callback?  where documented for crissakes?\par
\tab - BASS_ASIO_ChannelEnable links procs to channels.\par
\tab\tab - input and output channels have separate int numbering.\par
\par
how to create a buffered stream?\par
\par
DSP_Gain, DSP_StereoEnhancer, DSP_PeakLevelMeter... AWESOME!\par
Waveform class... WTF???  \par
\line VISUALS class!  VERY NICE.  looks like it can draw an instantaneous spectrum graph out of the box!  If only it could do it without allocation :-(  Oh well, at least it points the way and I can diddle my own FFT stuff relative to it.\par
\par
\par
OK so the overall model is:\par
- channels are identified by ChannelHandles\par
- channels can be enabled (input/output), which attaches a callback\par
- channels are often created on/from other channels\par
\par
DSP_BufferStream class looks useful for buffering the output of another stream, e.g. a mixer.\par
\par
Arrgh!  Why do none of the samples work? They all crash vshost.exe.\par
\par
OK, so BASS_SampleCreate looks to be for creating samples, and BASS_SampleSetData is for setting their data.  But this seems to require a contiguous byte array?!?!  How inna hell am I gonna\par
manage that?!\par
\par
- can I play one sample after the other and stitch them together myself via progress callback?\par
\tab - no, probably very unadvisable.\par
\par
\par
But then there is BASS_StreamCreate et al., "create a user sample stream."  BASS_StreamPutData looks much more like what I want, used with BASS_StreamCreatePush.\par
\par
Don't forget about BASS_SetDevice weirdness!\par
"DSPs can be applied to streams, but not samples."  So StreamCreatePush is it, with its handy example of stream copying via DSP proc!\par
\par
OK it's becoming clear:\par
- ASIO input channel gets ASIOPROC that copies into memory chunks.  (see SimpleASIOFx for example)\par
- Chunk manager tracks chunks vs. time.\par
- Can create a push stream over some time interval by just pushing all the data into it and letting it play, joining it to the ASIO output channel.  (see SimpleAsioFX for example)\par
\par
So perhaps the original plan will work:\par
- record into fixed size chunks\par
- when a loopie is cut, create a stream, and put all the chunks into it\par
- when doing effects, create subsequent streams and join them to output channel.\par
- should be able to join as much as necessary to output channel\par
\par
ALRIGHTY THAT SOUNDS LIKE A PLAN\par
\par
\par
Here's some code related to detecting the end of a track:\par
\par
\f3\fs16 track.TrackSync = \cf1 new\cf0  \cf2 SYNCPROC\cf0 (OnTrackSync);\par
\cf2 BassMix\cf0 .BASS_Mixer_ChannelSetSync(track.Channel, \cf2 BASSSync\cf0 .BASS_SYNC_END, 0L, track.TrackSync, \cf1 new\cf0  \cf2 IntPtr\cf0 (0));\par
\f0\fs20\par
USE ONE SYNC PER CHANNEL: {{\field{\*\fldinst{HYPERLINK http://www.un4seen.com/forum/?topic=12875.msg89538;hl=looping;topicseen#msg89538 }}{\fldrslt{http://www.un4seen.com/forum/?topic=12875.msg89538;hl=looping;topicseen#msg89538\ul0\cf0}}}}\f0\fs20\par
\par
USE VAM FLAG TO MAX HARDWARE RESOURCES: {{\field{\*\fldinst{HYPERLINK http://www.un4seen.com/forum/?topic=5937.msg40059;hl=samples;topicseen#msg40059 }}{\fldrslt{http://www.un4seen.com/forum/?topic=5937.msg40059;hl=samples;topicseen#msg40059\ul0\cf0}}}}\f0\fs20\par
\par
- replace circle with microphone - \b DONE\b0\par
\par
- launch ASIO from within XNA app - \b DONE\b0\par
\par
- get samples working\par
\tab - vshost.exe crash - fixed automatically by Program Compatibility Assistant (!!!)\par
\tab - couldn't find bassasio.dll - copy into bin directory\par
\tab - BadImageFormatException - change to x86 configuration\par
\tab - wrong bassasio.dll version - revert to 1.0 from 1.1\par
\tab - bass_fx.dll not found - download it\par
\tab - terrible crackling noise - load ASIO4ALL offline settings, DISABLE 44.1KHz <-> 48KHz conversion\par
\b\tab - AND IT SOUNDS PERFECT!!!!!\b0\par
\tab - :-D\par
\par
- run GetLevel-like code  - \b DONE\b0\par
\tab - basic ASIO sample has both of these, though without actually getting recorded data\par
\par
- render circle behind microphone, size proportionate to current level - \b DONE!!!!!!!!!!!\b0\par
\par
- state machine???\par
\par
\tab - default state: circle\par
\tab - transition to held: \par
\tab\tab circle -> red\par
\tab\tab // show beam\par
\tab\tab relocate sound\par
\tab - held state: red circle with beam and sound inside\par
\tab - transition to default: \par
\tab\tab circle -> white\par
\tab\tab // hide beam (color = transparent!?)\par
\tab\tab relocate sound back to mike\par
\tab - \b DONE!!!\b0\par
\par
\b NUMBERS TO LIVE BY:\par
48Khz x 4 bytes/float x 2 channels = 384KB PER SECOND.\par
\par
300 seconds x 384KB/sec = 109MB.\par
\par
ok that is manageable.\b0\par
\par
- define Chunk, Sample, Track, SamplePool - \b DONE\b0\par
\par
- add Recorder\par
\tab - allocate many MB of memory\par
\tab - \b DONE\b0\par
\tab\par
- get recorded data by some means - \b DONE\b0\par
\par
- create Track when recording begins - \b DONE\b0\par
- finish Track when recording ends, associate with Loopie - \b DONE\b0\par
\par
- TEST ALL THE ABOVE - \b DONE\par
\par
- \b0 build out infrastructure for multiple chunks in chunk pool - \b DONE\b0\par
\par
- add simple TextNode for status info - \b DONE\b0\par
\par
- display current usage in realtime while recording - \b DONE\b0\par
\par
- rewrite to use mixer stream - \b DONE\b0\par
\par
- actually start Track playing back (once only at first)\par
\tab ..... \b AAAAARGH!!!!!  sooo close but NOPE.\b0\par
\par
FLAILING AROUND:\par
\par
- double-check channel counts / infos - \b DONE\b0\par
\tab - make sure don't have dumb "off by one... power of 2" issue\par
\tab - looks like there was various stereo/mono confusion\par
\tab - also looks like the mixer stream is not set up all the way in StartAsio???\par
\par
- get rid of all BassAsioHandler - \b DONE\b0\par
\tab - too opaque\par
\tab - OK, input really is ASIO device 0, output really is ASIO device 1\par
\tab - channel 0 on both\par
\par
For reference, BassAsioHandler docs say:\par

\pard\li720 The following will be done internally:\par
\par
1. The ASIO device will be initialized (if already done, the ASIO device will just be set).\par
\par
2. The samplerate, format and number of channels will be determined from the given outputChannel.\par
\par
3. The ASIO device will be set to the determined samplerate. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and stream samplerate are different) that the ASIO output needs to be resampled.\par
\par
4. Output: use the AsioOutputCallback(Boolean, Int32, IntPtr, Int32, IntPtr) as the internal ASIOPROC.\par
\par
4. Enable and join the given asioChannel with the following channels according to the total number of chans of the outputChannel.\par
\par
5. Set the asioChannel format and samplerate according to the given samplerate and format of the outputChannel.\par
\par
Note: If the given asioChannel has already been enabled, it will be reused and not enabled and joined again! This means, that the channel number of the already joined channel will not be changed as well and might not match to the channel number of the given outputChannel.\par

\pard\par
\par
\par
- try push stream for sampled playback - \b DONE\b0\par
\tab - just to eliminate that possibility....\par
\tab - aaand, \b I AM FINALLY HEARING SOMETHING!!!!!!!!!!\par
\tab - looks like push stream really helped!\par
\tab - but, beat frequency and uneven mixing.\par
\tab - need something other than pushing blindly from the original input!\b0\par
\par
\b\i WOOOOOOOOOOOOOOOOOOOOO\b0\i0\par
QUICK CHECK IN!\par
\par
and then quit for tonight, can't deal with <6 hours sleep and MUST. WORK. OUT.\par
\par
\par
- add SYNCPROC to push entire samples into push streams\par
\tab - \b DONE!!!!!\par
\tab - and WORKS!!!!!!!!!!!!\b0\par
\par
\par
DONEDATE 2010/08/30:\par
\par
- look into seamless adding of new mixer streams\par
\tab - don't want ANY popping...\par
\tab - should I just precreate a bunch of Tracks, muted?\par
\tab - websurf for clues here\par
\tab - Ian suggested just not doing Stop/Start... \b DONE, WORKS!\b0\par
\par
- OK, OK, upgrade ALL libs\par
\tab - \b OH HELL YES, THE INPUT STREAM IS PERFECT NOW!!!\b0\par
\tab - \b DONE\b0\par
\par
- figure out why input stream is still ever so slightly crackly\par
\tab - \b DONE\b0\par
\par
- nail down how large the offset/latency is\par
\tab - experiment with configuring mixer / BASS / BASSASIO for smaller buffers\par
 \tab and higher update frequency\par
 \tab - \b DONE\b0  -- seems fine with only a 5 msec mixer buffer?\par
\tab\tab - but mixer still sounds weird....\par
\par
- add FPS counter\par
\tab - \b DONE\b0  but not clear how useful....\par
\par
- arrgh!  write eventing???  talking to a Track<byte>?  that's actually so beautiful I might just have to do it... but it would have to not talk to \i itself....\i0\par
\par
very frustrating that debug output doesn't work!\par
\tab - search for XNA help on that?\par
\tab - wow, Console.WriteLine writes to debug console!!!\par
\par
\tab - \b DONE\b0\par
\par
- figure out how to get mixer to sound a lot better (whatever that means....)\par
\tab - spam on each buffer change\par
\tab - give Chunks an Id and spam it\par
\tab - verify whether chunk pattern is well-formed\par
\tab - \b DONE\b0  -- totally well-formed.\par
\tab - but still garbley sometimes.  \par
\tab - hacked by adding EndChunk, seems to help a bit.\par
\par
\par
- put up a blinking metronome at fixed tempo (60 BPM?  nice and slow)\par
\tab - \b DONE\b0\par
\tab\par
\par
\par
- quantize all tracks to multiples of the beat frequency\par
\tab - WHAT DOES THIS MEAN, EXACTLY?????\par
\par
\tab - app needs to know what time it is down to 0.01 sec\par
\tab - track needs to save its start offset RELATIVE TO THE BEAT\par
\tab - when track is completed, needs to start playing AT THAT TIME\par
\par
\tab - so how do I implement that???\par
\tab\tab - shouldn't call SetData until that time?!\par
\par
\tab FUCKING ARRGH, is this just a doomed proposition?\par
\tab No, it shouldn't be.  But the question is how do you get it to line UP exactly???\par
\tab And what if you want it to be a continuous loop?  How do you NAIL that?\par
\par
\tab If it is a continuous loop, then it should be LONGER than the exact beat multiple.\par
\par
So.  You have:\par
\tab - start offset relative to beat\par
\tab - length of track in \i full beats\i0\par
\par
\tab When track is finished, should \i wait for the next start offset after the next full beat.\par
\tab\i0 If past that time, then what???  Let's not worry about that yet....\i\par
\par
\i0 How do you wait for a specific time?\par
\tab Can't use BASS for this....\par
\par
OK fine.  If track is <0.1 beats too long, then clip off the START of the track to make it an integral number of beats long.  Otherwise, zero-pad the track to make it an integral number of beats long.\par
\par
- hmm, that doesn't really work very well does it?  The zero-padding is a dead loss -- you can't hit the final beat nearly accurately enough.\par
\par
- OK, so lifting up on the button is really a CUE to STOP RECORDING WHEN THE TRACK HITS AN INTEGRAL NUMBER OF BEATS!!!\par
\par
- so it should set a flag in HolofunkBass, waiting for the right track length, rather than just bailing immediately.  OK that makes sense.\par
\par
BUT can't stay awake to do it.  Still very valuable yes yes, pip pip, tut tut.\par
\par
- \b DONE.\b0\par
\par
But time sync drifts between XNA GameTime and ASIO sample push time.  Should be locked at exactly two seconds, but look at the terrible drift:\par
\par
\f4\fs16 Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs \highlight3 22.14\highlight0 , beats 22.14]\par
The thread '<No Name>' (0x2450) has exited with code 0 (0x0).\par
The thread '<No Name>' (0x2010) has exited with code 0 (0x0).\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs \highlight4 24.23\highlight0 , beats 24.23]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs 26.23, beats 26.23]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs 28.24, beats 28.24]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs 30.25, beats 30.25]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs 32.25, beats 32.25]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs 34.25, beats 34.25]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs 36.25, beats 36.25]\par
Track #1 pushed sample to stream[chunk #1, start pos 1536, length 192000] at time [secs \highlight4 38.27\highlight0 , beats 38.27]\par
\fs18\par
\f0\fs20 That will obviously send everything to shit.  \par
\par
So, let's see about driving m_clock from the ASIO input proc...!?\par
\par
Still, it's so much closer that it's worth checking in :-D\par
\par
\b\fs36 - DONE!!!!!!!!!!!!!!!\b0\fs20\par
SYNC ACTUALLY WORKS \par
IT \i SOUNDS RIGHT!!!!!\i0\par
\par
\par
WHAT IS A CIRCLE?\par
- it is a Loopie.\par
- it has a scene graph node.\par
- it is maintained in the loopie collection in the Holofunk program.  keep it at top level for now.\par
\par
Holofunk has collection of Loopies\par
each Loopie has a scene graph node\par
Loopies get updated.\par
\par
LOOPIE INTERACTIONS\par
- first, pull trigger over empty space to make one\par
- release trigger to drop it \par
\tab - pulsing trigger makes more\par
\tab - dropping a loopie does NOT YET move other loopies away\par
\par
\b THEN\b0  BUILD ANYTHING SOUND-RELATED.\par
\par
MIKE \i IS \i0 THE RECORDER.  \par
\par
- first build basic recording infrastructure.\par
\tab - figure out how to grab into growing stream that I manage\par
\tab - nail down sample rate, time management, etc.\par
\par
- then add live playback.\par
\par
- then make mike loopie scale depend on current avg volume over last [update rate] interval.\par
\par
- then make loopie creation set a time point.\par
\par
- then make loopie release start... well... looping!\par
\tab - implement basic mixer\par
\tab - figure out how to get mixer buffers populated from sample history\par
\par
\b - THEN PLAY!!!!!!!!!!!\b0\par
\par
\par
- metronome next?  probably.\par
\par
- add output level meters on all Tracks\par
\tab - \b DONE\b0\par
\par
- when trigger released, drop a new circle\par
\tab - \b DONE\b0\par
\par
- display Loopies as circles, positioned at final drop location\par
\tab - \b DONE!!!!!\b0\par
\par
\par
(phew, that was an epic three-week hacking spree!!!)\par
\par
\par
\par
DONEDATE 2011/09/06:\par
\par
- hit minus again on silenced loopie to delete it altogether\par
\tab - \b DONE!!!!!\b0\par
\par
- fix left-channel-only bogosity\par
\tab - add in HolofunkBass.InputChannelCount\par
\tab - propagate it throughout\par
\tab - \b DONE\b0\par
\par
\par
\par
- get some retroactive recording support\par
\tab - eliminate that last little annoying bit of latency\par
\tab - requires real state machine in HolofunkBass?\par
\tab\tab - at least requires a proper coordinated architecture with the ASIO input proc....\par
\par
gah.  so what EXACTLY do we want to do here?\par
\par
1) have two RecycledChunks, at least as many samples each as our tuned input latency.\par
2) have an AsioTarget object:\par
\tab - set by the UI thread only\par
\tab - points to the current buffer to copy into\par
\tab - has a means to obtain the next buffer if the current one fills\par
\par
ASIO thread copies into current AsioTarget buffer if there is room, and updates the AsioTarget.\par
If there is not room, it gets the next buffer (which MUST be big enough) and copies into that.\par
In any case it updates the AsioTarget with the result.\par
\par
The UI thread, when making a new track, must do this:\par
- Swap in an AsioTarget for the first non-retroactive chunk of the new track.\par
\tab - From this point the ASIO input proc is writing into the track.\par
- The new track contains a blank chunk slot at the beginning.\par
- The UI thread then copies the recycled data into a new chunk,\par
\tab and sticks that in the first track slot.\par
- Result: the ASIO proc doesn't drop any data, the recycled chunks are cleared and freed,\par
\tab and the UI thread continues on its merry way.\par
\par
What about beat clamping?\par
- First, if we get a stop request, then we check -- from the UI thread -- how close we are to the end.\par
\tab - note that the track will be growing asynchronously through this process!\par
- If we are just over the end, then:\par
\tab - swap back in the recycling AsioTarget (this stops recording new sound)\par
\tab - trim the END (!)\par
\tab - start it playing\par
\tab - return to ready-to-record state\par
- if we are not yet at the end, then:\par
\tab - leave the recording AsioTarget in place\par
\tab - set the timer\par
\par
hmmmmm, the timer is called from the game update thread!!!\par
and this means it can be delayed by rendering, correct?!?!?!  :-(  :-(  :-(\par
but we WANT it to be on the game update thread....\par
\tab maybe the asio input proc should post an event on the game thread...?\par
\tab hmm, punt this issue for now.\par
\par
- AsioTarget object\par
\tab - single pointer update, should not tear on x86 (right???)\par
\tab - right, else all the relativistic programming stuff would break\par
\par
\b - DONE...\b0  but BROKEN!\par
\tab - metronome drifts rapidly off the beat!\par
\tab - how can this be???\par
\tab - need to compare it to the previous code in detail.... sigh....\par
\par
OK now it is 9 pm and much more clear-headed :-D  Let's do this.\par
\par
EXPERIMENTS TO TRY, ALL OF THEM JUST CHECKING BASIC METRONOME SYNC:\par
- revert to previous version before stereo fix \par
\tab - debug mode: DAMMIT, NOT SYNCED PERFECTLY.\par
\par
\f4\fs16 Track #1 pushed sample to stream[chunk #1, start pos 1280, length 96000] at time [4331008 timepoints, 90.2293333333333 secs, 90.2293333333333 beats]\par
Track #1 pushed sample to stream[chunk #1, start pos 1280, length 96000] at time [4379136 timepoints, 91.232 secs, 91.232 beats]\par
Track #1 pushed sample to stream[chunk #1, start pos 1280, length 96000] at time [4427264 timepoints, 92.2346666666667 secs, 92.2346666666667 beats]\par
Track #1 pushed sample to stream[chunk #1, start pos 1280, length 96000] at time [4475392 timepoints, 93.2373333333333 secs, 93.2373333333333 beats]\par
\fs18\par
\f0\fs20 OK, so that explains a lot :-(\par
After two minutes, totally out of phase.\par
\par
\tab - release mode (no spam in syncproc): SAME.\par
\par
ok, so at least it is consistent and not directly related to subsequent changes, that simplifies matters.  Could fix it in the past and then forward port the fix... if a fix exists....\par
\par
so... WHY?\par
- expose total number of samples on the clock\par
- record total number of samples in the track\par
\tab - aaah, no point to that, it'll never line up perfectly....\par
\par
OK, looks like BASS_SYNC_MIXTIME on the SYNCPROC might have been the core problem...?!?!?!\par
let's see.  Makes sense anyway, don't want the stall to be audible....\par
\par
feh, doesn't help enough.\par
\par
So what to do?  Purely hack it?  Put in some kind of hysteresis, tweaking the track length on each replay to drive it closer to perfect sync?  That seems like a pain in the ass, but possibly necessary anyway.....\par
\par
\b OH HELL YES, IT WORKS ***PERFECTLY***.\par
Now can let the damn thing run and it stays EXACTLY on the beat for >5 minutes straight!!!!!\par
and even better, the data shows it is staying perfectly centered!\par
\b0\par
\f4\fs16 Track #1 SyncProc invoked at time [18862080 timepoints, 392.96 secs, 392.96 beats]; average sync length (timepoints): 48025.6; timepoint drift: -25.60156; loop lag (timepoints): 397\par
Track #1 SyncProc invoked at time [18909696 timepoints, 393.952 secs, 393.952 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 359\par
Track #1 SyncProc invoked at time [18957824 timepoints, 394.954666666667 secs, 394.954666666667 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 321\par
Track #1 SyncProc invoked at time [19005952 timepoints, 395.957333333333 secs, 395.957333333333 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 283\par
Track #1 SyncProc invoked at time [19054080 timepoints, 396.96 secs, 396.96 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 245\par
Track #1 SyncProc invoked at time [19102208 timepoints, 397.962666666667 secs, 397.962666666667 beats]; average sync length (timepoints): 48025.6; timepoint drift: -25.60156; loop lag (timepoints): 257\par
Track #1 SyncProc invoked at time [19150336 timepoints, 398.965333333333 secs, 398.965333333333 beats]; average sync length (timepoints): 48128; timepoint drift: -128; loop lag (timepoints): 321\par
Track #1 SyncProc invoked at time [19198464 timepoints, 399.968 secs, 399.968 beats]; average sync length (timepoints): 48128; timepoint drift: -128; loop lag (timepoints): 385\par
Track #1 SyncProc invoked at time [19246080 timepoints, 400.96 secs, 400.96 beats]; average sync length (timepoints): 48025.6; timepoint drift: -25.60156; loop lag (timepoints): 397\par
Track #1 SyncProc invoked at time [19293696 timepoints, 401.952 secs, 401.952 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 359\par
Track #1 SyncProc invoked at time [19341824 timepoints, 402.954666666667 secs, 402.954666666667 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 321\par
Track #1 SyncProc invoked at time [19389952 timepoints, 403.957333333333 secs, 403.957333333333 beats]; average sync length (timepoints): 47923.2; timepoint drift: 76.80078; loop lag (timepoints): 283\par
\fs18\par
\b\i\f0\fs20 I ROCK!!!!!\b0\i0\par
\par
- try BASS_SYNC_END as per Ian\par
\tab - total bust!\par
\par
- put in FAQ workaround for depth buffer oddity\par
\tab - try adding back in video masking???\par
\tab - nope, never mind, none of it applies if you're using DepthAndPlayerIndex, which I am\par
- but did add some intensity shading, so that's nice - \b DONE\b0\par
\par
- add in smoothing filter for hand location - \b DONE\b0\par
\par
- multiple colors for loopies (rotating through fixed set) - \b DONE\b0\par
\par
- home button to wipe the whole set - \b DONE\b0\par
\par
- make it so waving over loopies with minus/plus held silences/enables them\par
\tab - state machine gets events for minus/plus\par
\tab - can install an effect on the game state\par
\tab - effect applies to all closest loopies touched during effect's lifetime\par
\tab - \b DONE!!!\b0\par
\par
- minus/plus buttons mute/unmute individual loopies\par
- trigger and minus will delete a loopie\par
\par
\par
\par
DONEDATE 2012/02/01:\par
\par
- download C++ Wiimote library\par
\tab {{\field{\*\fldinst{HYPERLINK http://wiiyourself.gl.tter.org/ }}{\fldrslt{http://wiiyourself.gl.tter.org/\ul0\cf0}}}}\f0\fs20\par
\par
- get Kinect For Windows final SDK once it goes public - \b DONE\b0\par
- install it - \b DONE\par
\b0\par
- run Kinect Explorer app in C++ - \b DONE, FIRST TRY YAYYY!!!\b0\par
\line - investigate using that app as basis for next Holofunk\par
\par
...god, it's unchanged since 1995 when last I looked at a Windows C++ app.\par
Is it worth it?  Well, let's look a bit further.  But my God, the unvarnished message loop....\par
\par
OK, well, once we get into NuiImpl.cpp things get incrementally more reasonable, but the gibberish is still pretty objectionable.  Maybe \i should\i0  go back and look at keeping most of it in .NET... but then what about Win8?  Hmm hmm hmm.  Well, let's see.\par
\par
well alright, it's not so bad in a creaky old familiar kind of weirdy way.  Sure is nice to know that everything is effectively [NoAllocation]....\par
\par
So Kinect needs its own thread.  And there's no backtalk from the Kinect thread to the main app.  Will need to ask Joe for a copy of his book....\par
\par
Wow, the Kinect thread drives D2D directly.  Well, that might not be \i so\i0  bad... can a single thread handle both ASIO and Kinect?  But we really don't want to have that, do we?\par
\par
No, no we don't.  We want separate threads for ASIO and Kinect.  And what about fuckin' Wiimote???\par
\par
What about BASS?  Let's look at a BASS C++ ASIO sample.\par
\par
...THERE ARE NONE, AAAAAGH.  Oh well.  But how do you build the C sample .exes?\par
\par
\par
OK, I clearly have to evaluate the cost of reviving the .NET version, because this C business is just rather ridiculous.  Looks like you communicate with BASS via Windows messages?!?!?!\par
\par
...but what about the death of XNA?!?!?!  fuckin' sigh.\par
\par
Anyway, let's take one look at the wiimote piece.\par
...nnnope, dead batteries.  OK, tomorrow night.  or something\par
As regards code:  well, at least it's C++, but the polling looks rather weird, how do you jibe that with the Kinect sensor's WaitForMultipleObjects?  And then the ASIO thread is going to be calling the ASIO callback... so that'd be a third thread then.  GAH.\par
\par
Definitely worth 1) porting the old version to the current SDK, 2) evaluating Gen2 GC pressure and general allocation rate via all means.  Because if I can get the GC issues dealt with, it would just be soooooooooo much more productive to stay in .NET mostly... hmm, should probably still look at mixed mode for ASIO, but all the Kinect stuff would stay.\par
\par
So yeah, this would be a bet on porting it to Midori eventually :-)  Screw WinRT, no one knows how to get all the pieces there, the Wiimote libraries will never make it.\par
\par
\par
\par
- get Holofunkinect compiling with latest SDK - \b DONE\b0\par
- get all of Holofunk compiling with latest SDK - \b DONE\b0\par
- run and debug Holofunk with latest SDK\par
\tab - especially watch out for ColorConversion!!!  :-O\par
\tab - \b DONE, but...\b0\par
\par
-\b  FIX HORRIBLE CONTINUAL STATIC\b0\par
\par
what did I do to get Skyrim working?  only real audio tweaks done on this machine since Holofunk.\par
\par
- check Sound control panel...\par
\tab - hmm, Kinect audio was set as default!  DISABLED.\par
\tab - Sound > Recording > Line 1/2 > Properties > Advanced > Default Format\par
\tab\tab - WAS 2 channel \b 24 bit\b0  48000 Hz (studio quality)\par
\tab\tab - CHANGED BACK to 2 channel, 16 bit, 48000 Hz (DVD quality)\par
\tab - and likewise for Sound > Playback > Line 1/2 > etc....\par
\par
- ok, so now how do I hear the mic with pass-through audio?\par
\tab - FastTrack Pro is reacting with green level light, Sound control panel shows levels on mic...\par
\tab - ...but can't hear anything passed through.\par
\par
\b YAYYYYY IT ALL WORKS!!!!!!!!!\par
PHEEEEEEEEEEW.\par
\b0\par
- CHANGE Hz BACK TO 48000 IN HOLOFUNKBASS - \b never mind, it was never changed\b0\par
\par
- go back and research the Skyrim 48K audio issue - \b DONE\b0\par
\par
- investigate all available audio control panels etc. - \b DONE\b0\par
\par
- add back error code checking in all ASIO methods - NO NEED\par
\par
- FIX IT - \b DONE!!!!\b0\par
\par
\par
RACE CONDITION!!!\par
\f4\fs18 Starting recording; getting 2400 retroactive samples...\par
    Sample1 is sufficient; prepending itTrack #7: completed sample [chunk #\par
Updating initially empty sample: [chunk #194, start pos 0, length 2400]\par
Start recording: current time: [28993536 timepoints, 604.032 secs, 906.048 beats]\par
\f0\fs20\par
It was prepending Sample1 to the new track concurrently in time with the ASIO thread overlapping it and spamming the not-yet-copied Sample struct!  (By the time the debugger got there, the array copy had completed, but the struct that Spam was calling on was still uninitialized.)\par
\par
\f5\fs16         \cf1 public\cf0  \cf1 void\cf0  Append(\cf2 Sample\cf0 <T> sample)\par
        \{\par
            \cf1 if\cf0  (m_samples.Count == 0) \{\par
                m_samples.Add(sample);\par
\par
                \cf2 Spam\cf0 .Write(\cf5 "Track #"\cf0 );\par
                \cf2 Spam\cf0 .Write(m_id);\par
                \cf2 Spam\cf0 .Write(\cf5 ": appending initial sample"\cf0 );\par
                sample.Spam();\par
                \cf2 Spam\cf0 .WriteLine();\par
            \}\par
            \cf1 else\cf0  \cf1 if\cf0  (m_samples[m_samples.Count - 1].AdjacentTo(sample)) \{\par
                \cf6 // coalesce adjacent samples\cf0\par
                m_samples[m_samples.Count - 1] = m_samples[m_samples.Count - 1].MergeWith(sample);\par
            \}\par
            \cf1 else\cf0  \{\par
                \cf2 Spam\cf0 .Write(\cf5 "Track #"\cf0 );\par
                \cf2 Spam\cf0 .Write(m_id);\par
                \cf2 Spam\cf0 .Write(\cf5 ": completed sample "\cf0 );\par
                \highlight4 m_samples[m_samples.Count - 1].Spam();\f6  // boom\f5\par
\highlight0                 \cf2 Spam\cf0 .WriteLine();\par
\par
                \cf2 Spam\cf0 .Write(\cf5 "Track #"\cf0 );\par
                \cf2 Spam\cf0 .Write(m_id);\par
                \cf2 Spam\cf0 .Write(\cf5 ": appending initial sample "\cf0 );\par
                sample.Spam();\par
                \cf2 Spam\cf0 .WriteLine();\par
\par
                m_samples.Add(sample);\par
            \}\par
\f0\fs20\par
EXACTLY the kind of trouble the ring buffer will have to avoid.\par
\par
No no no, it's all due to initiallyEmptySample, which is LEGITIMATE.  But the track shouldn't start playing until it's been filled in, right???\par
\par
So, I guess the mixed mode thing is more mandatory than I thought!\par
\par
- reacquaint with my BASS library\par
\tab - understand thread race deeply, to wit:\par
\tab - it's simple :-)\par
\par
- move all actual sound data management to ASIO thread\par
\tab - starting, stopping recording, etc.\par
\tab - should always be constant amount of work\par
\par
- need wait-free two-way queues between each side\par
\tab - how???\par
\tab - queue state is 32 bits: 16-bit current head index, 16-bit current length?\par
\tab\tab - no, that requires CAS.\par
\tab\tab - do we *have* CAS in .NET???  let's frickin' check!\par
\tab\tab - System.Threading.Interlocked.CompareExchange<T>(ref T, T, T)\par
\tab\tab\tab - NICE.\par
\par
- ok, so lock-free queue works as:\par
\tab - T[] m_contents\par
\tab - Int32 m_state (16-bit start index, 16-bit length)\par
\tab\tab - only up to 64K entries, it's fine\par
\tab - enqueue gets the value, updates the array, calculates the updated state, tries CAS; if fails, retries\par
\tab - dequeue does the converse\par
\par
- add debug asserts to each queue to ensure that enqueue and dequeue are only ever done from 1) consistent and 2) disjoint threads!  nice.\par
\par
- then we have two lock-free queues in either direction.  Does .NET 4 not already have this???  Let's check THAT!\tab\par
\tab - no, evidently not.  oh well :-)\par
\tab - System.Threading.Thread.MemoryBarrier() FTW\par
\tab - VERY USEFUL: MSFT GDC lockless presentation\par
\tab\tab - {{\field{\*\fldinst{HYPERLINK http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=23107 }}{\fldrslt{http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=23107\ul0\cf0}}}}\f0\fs20\par
\tab - also this series of blogs on lock-free data structures in C#\par
\tab\tab - {{\field{\*\fldinst{HYPERLINK http://www.boyet.com/Articles/LockfreeStack.html }}{\fldrslt{http://www.boyet.com/Articles/LockfreeStack.html\ul0\cf0}}}}\f0\fs20\par
\tab\par
- and WHY are we doing all of this???\par
\tab - because we need inter-thread communication.\par
\tab - but why not just synchronize???  there's no GC risk with that!!!\par
\par
- huh.  you're right :-O\par
- ok, let's just use Queue.Synchronized, why be fancy?  will be nice to save the time.\par
\par
- so what we are writing is command records, Command/Parameter, WPARAM/LPARAM all over again :-D\par
\par
- if a GC hits our ASIOPROC is screwed anyway\par
\par
- make two-way communication queues between ASIO thread and main thread\par
- each queue allows only one thread to enqueue, and only one OTHER thread to dequeue (check this with wrapper)\par
- two separate queues, one for each direction\par
\par
- WHY the queues?  Because each thread needs to stick to its schedule, and shouldn't be woken up by anything other than its normal tick; yet we need a way for each thread to request the other to react in some way\par
\par
- don't need to be wait-free queues because both threads are subject to the same GC, so a GC will screw them both\par
\tab - true wait-free queues would be required if we split the ASIO stuff out into C++\par
\par
\par
- need to understand my own code's control flow again...\par
\par
Main thread:\par
StartASIO()\par
\tab sets up MixerToOutputAsioProc() (the one that updates the clock)\par
\tab sets up encoder\par
\tab sets up input push stream\par
\tab sets up peak level meter\par
\tab starts ASIO\par
\tab All of this seems fine thread-wise, so leave it [MainThread].\par
\par
Track.StartPlaying() (on MAIN THREAD)\par
\tab create push stream\par
\tab m_bass.AddStreamToMixer(HStream, IntPtr, SYNCPROC);\par
\par
- OK, implemented the queues, too sleepy to test tonight, try it tomorrow.\par
\par
\par
\b\fs56 HOLY SHIT ALL MY RACE FIXES WORKED THE FIRST GODDAMNED TIME!!!!!\par
THAT LIKE NEVER HAPPENS!!!\par
:-D :-D :-D :-D :-D\b0\fs20\par
\par
well that is enough for victory tonight :-)  (and can't sing too loud with Michelle's mom sleeping in the next room)\par
\par
WHY does the volume have to be turned ALL the way up?  very odd.\par
\par
- fix skeleton & UI\par
\tab - hmm, things are offset, why?\par
\tab - WHO CARES, MOVE IT BY (0, -50)!!!\par
\par
- enqueue thread affinity assertion blew up!\par
\tab - because WIIMOTE HAS ITS OWN THREAD!!!\par
\tab - so fuck the affinity checking, it's not paying its way and it's SAFE ANYHOW.\par
\par
- hmm, this decoupling thing seems to have impressively reduced the number of audible GCs!  GO FIGURE\par
\par
\par
DONEDATE 2012/04/12:\par
\par
- PUT HOLOFUNK ON THE LAPTOP\par
\tab - \b DONE\b0\par
\par
\par
- research old thread about possible fix for time out of sync when looping\par
\tab - get it minimally working - \b DONE\par
\par
\par
- \b0 refactor UpdateEmptySample, beat counting, etc., to get greater determinism and eliminate code not needed now that the ASIO thread does everything\par
\tab - first standardize on "int TimepointsPerBeat" -- quantize EVERYTHING precisely - \b DONE\b0\par
\tab - then revise recording code per scribbled notes\par
\tab\tab - \b DONE!  \b0 at least as far as eliminating crappy math and making everything precise.\par
\tab\tab - and precision is way up, yay!\par
\par
- test recording longer samples -- seems to be some problem (over two measures???)\par
\tab - \b DONE!!!\b0   can only push one sample at a time when using BASS_SYNC_END, go figure.\par
\tab but now it is tight, tight, TIGHT!!!\par
\par
- mute gesture touches all in range, not only closest, and continues to do so\par
\tab - but delete gesture still touches only single closest\par
\tab - use distance-squared in comparison loop? - was already, go me\par
\tab - \b DONE\b0  \par
\par
- measure markers!!!\par
\tab - modify muting/unmuting: press once means mute on NEXT measure; double-press means immediate\par
\tab - tracks can be 1, 2, or multiple of 4 beats long\par
\tab - track stop length is calculated internally\par
\par
alright, that sounds fine, fine, fine.\par
\par
RACE CONDITIONS HERE?????\par
\tab scene graph is consumed by XNA thread.\par
\tab scene graph is MUTATED by... what?  XNA thread?  is that true?\par
\tab\tab new loopies are added when responses processed on XNA thread, so that's OK.\par
\tab\tab BUT loopies are DELETED on the WiimoteLib thread, perturbing the scene graph during traversal!!!\par
\tab\tab BLAH!\par
\par
\tab simple thing to do is just to marshal everything over to the XNA thread... but that's more latency....\par
\par
\tab well, we haven't actually seen any bad effects from this yet, have we?  no.\par
\tab but we could, if we were deleting things and recording things in a tight interleaving.\par
\tab anyway, keep it strongly in mind.\par
\par
\par
m_mikeSignal should become another rendered loopie pulling its size from the current mike signal.\par
\tab should we change its parent???\par
\tab well, now we just force its transform to be where the appropriate hand is... effectively the same???\par
\par
yes, it would be nice to be able to change parents.  does current scene graph support that?\par
\tab no, no it doesn't, insofar as parents are immutable.\par
\tab otherwise moving a child would definitely lead to glitches during rendering that conflicts with a move.\par
\par
- ok, worst comes to worst, we synchronize on the Holofunk instance itself at the top of the Update, Render, and Wii-event-handler routines.  Until we hit trouble, though, don't sweat it.\par
\par
OK HOW EXACTLY IS THIS GOING TO WORK?\par
\tab the scene graph hierarchy: does it even function at all?\par
\tab test code said it did....\par
\tab RenderedLoopie needs a List<SpriteNode> for all the children of the parent sprite\par
\tab\tab does the scale of that sprite spread down???  it had better not!\par
\tab\tab\tab might need another lower scale transformation or something....\par
\tab\tab most crucially need all this machinery for the currently active one!\par
\tab\tab ok, so need to decouple duration from FloatTrackness\par
\tab\tab\tab (so can have a beat meter even for the currently recording not-yet-track)\par
\par
NO NO NO.\par
the concept is, scene graph nodes can have smarts, it's OK.\par
but they should be VISUAL elements not SEMANTIC APP elements.\par
So, specifically, SpriteNode is fine and well defined.\par
\par
Then adding a track is really adding a whole sub-hierarchy.  Who manages the whole hierarchy?\par
\tab Why not have a LoopieNode?\par
\tab Contains a GroupNode which consists of \par
\tab 1) the sprite (with a property on the LoopieNode to reach it), \par
\tab 2) the BeatNode.\par
\par
Then LoopieNode can expose properties which allow access to the lower items.\par
\par
ASIO thread is well handled.  XNA and WiimoteLib threads can plausibly be the same.  That leaves only the Kinect thread, and the Kinect thread merely updates state variables; the texture update is the worst issue.  Is there a thread-safety problem around that?  Until we see one, let's not sweat it.\par
\par
\par
\par
YAAAAAAAAAAAAAAAY!!!!  Now we have a real scene graph hierarchy with local transforms that ACTUALLY do something!  And the origin is working properly!  Secret:  ADD translation but MULTIPLY scale.  IS A HAPPY.\par
\par
\par
So now we are really set up to add the BeatNode... maybe tomorrow night!\par
\par
We also want a BeatNode that illustrates how long the "track" is, and what beat of it we're currently on.\par
\tab It does this functionally, by getting a Moment for now, and a Moment for the "track" duration.\par
\tab So implementing that is job one.\par
\tab\b DONE!!!\b0\par
\par
\par
\b FINAL FEATURES\b0\par
\par
- add art for new icons\par
\tab\b DONE\b0\par
\par
- add some kind of sound-cancel icon for mute mode - \b DONE\b0\par
- add speaker-up icon for unmute - \b DONE\b0\par
\par
- only delete if there were NO unmuted tracks in the just-hit set - \b DONE\b0\par
\par
- fix the measure markers to be circles - \b DONE\b0\par
\par
- make mike red when recording - \b DONE\b0\par
\par
- tempo change only when no tracks playing or recording - \b DONE\b0\par
- tempo in status line - \b DONE\b0\par
\par
- status line smaller - \b DONE\b0\par
\par
- remote battery level in status line - \b DONE\b0\par
\par
- skeleton lock - \b DONE\b0\par
\tab - make it be CurrentSkeleton\par
\tab - track m_currentSkeletonPlayerId, update whenever skeleton unavailable\par
\par
- add highlighting for touched tracks - \b DONE\b0\par
\par
- modify grouping:  minus mutes ALL sounds within radius (rather than just closest at that instant) - \b DONE\b0\par
\par
- line drawing - \b DONE\b0\par
\par
- add red line connecting mike and hand when recording - \b DONE\b0\par
\par
- implement groups on screen (screen areas, highlighted borders) - \b DONE!\b0\par
\tab - render white lines whenever 1) hand in that quadrant, 2) loopie(s) in that quadrant, 3) no higlighted loopies\par
\tab - loopies are highlighted when quadrant is highlighted\par
\par
- fix issue with new loopie sticking to mike - \b DONE!\b0\par
\par
- add effective loopie scale-down - \b DONE\par
\b0\par
- try scale at 0.7 down to 0.5 just for grins - \b DONE\b0\par
\par
\par
\par
DONEDATE 2012/06/18:\par
\par
- when deleting loopie, don't switch instantly into "select all in group" mode\par
\tab - this lets you delete a standalone loopie without instantly muting the rest of the group\par
\tab - DONE\par
\par
\par
panning and effects generally:\par
- where does effect state live?\par
- do we make effects relatively generic?\par
- how do we implement the parameter UI?  (e.g. how do we decompose the responsibilities?)\par
\par
\par
let's start with the last.  PARAMETER UI:\par
- define the layout\par
\tab - the four SpriteNodes to indicate what you're effecting\par
\tab - the delimiting box\par
\tab - the alpha'ed crosshairs\par
\tab - the envelope square\par
\par
- may need to generalize the concept of LoopieFunc?\par
\tab - no, not really.\par
\tab - but do need some helper methods on scene graph\par
\tab\tab - MapWiimoteToParameterSpace\par
\tab\tab - SetParameters (only valid when showing parameter UI)\par
\tab - also need to parameterize the loopie-selection behavior\par
\par
- how do we encapsulate the parameter envelopes?\par
\tab - Parameter is (in the abstract) a (Moment -> float) function\par
\tab - define ConstantParameter for the simple initial case\par
\tab - define TrackParameters class for all the relevant parameters\par
\tab\tab - pan, volume first\par
\tab - Parameter can have default initial value\par
\par
- need to pass the TrackParameters collected during recording into the new Track\par
\tab - so TrackParameters becomes a property of Track\par
\par
- what about interaction with microphone???\par
\tab - perhaps the last recorded TrackParameters are sticky?\par
\tab - perhaps there is a CurrentParameters instance that sticks?\par
\tab - so you can go into parameter space without anything selected....?\par
\par
ack!  but how do you select NOTHING when the screen is full?\par
\tab - HOLD THE MIKE TO YOUR FACE.\par
\tab - new events: MikeCloseToFace, MikeFarFromFace\par
\par
when mike is close to face, there is nothing selected.\par
then you can go into parameter space and affect the mike itself.  or rather, the "current parameters"\par
\par
EFFECT LAYOUT:\par
- left: pan\par
- down: volume\par
\par
that's it, at first :-)\par
\par
CODE TO IMPLEMENT THE EFFECTS:\par
\par
pan:\par
Bass.BASS_ChannelSetAttribute(m_hStream, BASS_ATTRIB_PAN, floatValue); // -1 to 1\par
\par
volume:\par
Bass.BASS_ChannelSetAttribute(m_hStream, BASS_ATTRIB_VOL, floatValue); // 0 to 1\par
\par
OK.  So, changes to state and to state machine.\par
\par
State adds:\par
- MicrophoneParameters: the current set of envelope values for the microphone\par
- RecordedParameters: the parameters currently being recorded (a subset of MicrophoneParameters)\par
\par
Seems like we want some kind of partial map here.\par
- Parameters: a collection of Parameter instances\par
\tab - can enumerate the contained parameters\par
\tab - can update other Parameters (CopyInto operation)\par
\par
Parameters are indexed by \i specific Parameter types.\par
\i0 We don't use strings, we use typeof(ParameterSubtype)!\par
\par
Parameter subtypes themselves have the ability to \i apply themselves to a BASS stream at a point in time.\i0\par
So Parameter instances are a HolofunkBass concept.  Same with ParameterSets (which are really more like Type -> Parameter maps).\par
\par
alright, I like that.\par
\par
Sooooo, the UI change is:\par
\par
- When mike is NOT near mouth:\par
\tab - initial state has circle causing selection\par
\tab - selection changes based on proximity of wii hand\par
\tab - pulling trigger goes into record mode as today\par
\tab - minus/plus work as today\par
\par
- When mike IS near mouth:\par
\tab - NOTHING is selected. \par
\tab\tab - YOWACK!  That can't work.  What if you are in minus mode and you sweep across your face?\par
\tab\tab - Answer: this "nothing is selected" behavior occurs \i only in initial state.\par
\tab\tab\i0 - But then what if you want to select something that's where your head is?\par
\tab\tab - It's the MIKE that's near the mouth.  DUH!  So it's fine.\par
\par
\tab - but still we'll have that behavior only in initial state.\par
\tab - So, nothing is selected when in initial state and mike is near mouth.\par
\par
\tab - D-pad... whoops, did we just lose tempo shift?  If D-pad triggers parameter mode, and if you want to get parameter mode while using the mike only, then yes we did.\par
\tab - what to do about it???  make tempo shift a parameter available only with no active music!!!  hmm.\par
\par
\par
SOON: holding down trigger WHILE holding down A starts recording\par
\par
WHAT IF YOU DO THAT WHILE YOU ARE ACTUALLY RECORDING A TRACK?\par
can you position new tracks in parameter mode???  UGH!!!!!!\par
...no, why UGH?  \par
\tab - because what the fuck state are you in?  really calls for concurrent states (OR-states).\par
\tab - you're actually in Envelope And Track Recording Mode.\par
\tab - and how does it work if you let go of the A button before you let go of the trigger?\par
\par
nonetheless, conceptually you could imagine that it would simultaneously have the unconstrained circle moving around with the usual red-mike-sound in it, AND the constrained parameter square pinned to the inner box.  \par
\par
But what about the above issues?\par
SIMPLER JUST TO NOT ALLOW THAT.\par
trigger when in microphone parameter mode does NOTHING.\par
can sort all the other shit out later if I even GET that far for fuck's sake!\par
\par
So, final interaction:\par
\tab - D-pad is tempo shift w/no tracks\par
\tab - D-pad is nothing when tracks exist\par
\tab - A button enters parameter mode; home gets you out\par
\tab - IN parameter mode, D-pad lets you choose the axes\par
\tab\tab - left: pan; right: chorus\par
\tab\tab - down: volume; up: filter\par
\tab - A button in parameter mode sets the current parameter(s)\par
\tab - Holding down A animates the transition\par
\tab - If tracks are selected, it applies to the tracks\par
\tab - If you entered with no tracks selected, it applies to the microphone parameters\par
\par
\par
And that's it for tonight!  If I can get that in, it's super good.\par
\par
\par
MICROTASKS:\par
- implement Parameter abstract base (supports min, max, default, time-to-float interpolation)\par
- implement ConstantParameter subclass\par
- implement Effect abstract base (defines list of ParameterTokens)\par
- implement PanEffect and VolumeEffect\par
- implement AllEffects class that lists all available effects\par
\tab - and can calculate the set of all ParameterTokens!\par
- EFFECTS ARE STATELESS!\par
\tab - given a ParameterSet and a time, they can extract their tokens and apply themselves.\par
\tab - that means we will want efficient ParameterSet lookup from typeof(Effect) -> ParameterToken -> Parameter value.\par
\par
- and we just use the generic AllEffects to go from a Track's ParameterSet to side-effecting all the appropriate BASS channels!  HELL YEAH!\par
\par
OK SO THE GENERAL CONCEPT HERE IS:\par
effects define parameters.\par
the set of all effects defines the set of all parameters.\par
IN PRINCIPLE, one can make an arbitrary mapping from:\par
\tab UI axis -> SET OF PARAMETERS ACROSS MULTIPLE EFFECTS.\par
\par
That is, one could envision a setup where the left-right axis was "low frequency reverb -> high frequency chorus" and the top-bottom axis was "soft low pitch -> loud high pitch".  Then interpolating those "presets" would update many parameters across many effects simultaneously.\par
\par
So what we would need is a data structure that represented all of this sparsely.\par
\par
This would be a pure set of Parameters, each with its ParameterToken and... its containing Effect?  No, instead, the \i type of\i0  its containing \par
Using types for effects is still well-defined.  But what we want is some kind of ParameterToken singleton construction pattern, so each effect can define its set of parameters, yet they can all be aggregated and compared meaningfully.\par
\par
This then gives a well-defined meaning to the D-pad: it lets you select WHICH parameters a given axis endpoint affects; it can affect many of them!  (eventually!)\par
\par
OK I THINK I REALLY LIKE THIS.  It's exactly what Beardyman was talking about:  fade between two completely arbitrary sets of parameters.  Only issue is you can't have overlap... or maybe you can and it just takes the average.\par
\par
\par
\par
that's all pretty quick alright.  THEN:\par
\par
- add MicrophoneEffectSet to current state\par
- add EffectSet to Track class\par
\par
- factor out touched-loopie logic\par
\tab - should be a particular kind of operation implemented in the state machine and plugged in\par
\tab - parameter UI should be a different logic altogether\par
\tab - "nothing selected because mike near head" should be yet another logic\par
\par
- add scene graph elements for parameter UI\par
\tab - bounding box (center of screen, 1/4 the screen area)\par
\tab - square\par
\tab - axis label sprites\par
\par
- add scene graph elements for mike-head proximity\par
\tab - red dot on mike\par
\tab - red dot in cursor-circle\par
\par
- modify state machine:\par
\tab - initial state becomes aware of mike-head proximity\par
\tab\tab - engage red dot based on proximity\par
\tab\tab - set selection behavior based on proximity\par
\tab - press A button to switch into Effect state\par
\tab\tab - default to pan/volume\par
\tab\tab - remember which effects you have selected on each axis (based on Type)\par
\tab\tab - really you don't have effects on each axis, you have parameters... actually EffectParameter\par
\tab - EffectUpdate state (when A down in Parameter state) updates the effects on each frame\par
\tab\tab - applies to all selected Loopies, or to the MicrophoneEffects if none\par
\par
- no, dammit, you SHOULD be able to record in parameter state!  What if you want to pan rapidly and knock off some quick tracks?!\par
\par
gah, really want that now.  how hard is it?\par
\par
- in parameter state, trigger WITHOUT A BUTTON puts you into RecordingDuringEffect state, basically as usual.\par
\tab - Behavior is same as Recording state.\par
\tab - A button is IGNORED in RecordingDuringEffect state.\par
\tab - When you let go of trigger from RecordingDuringEffect state, you revert to Effect\par
\par
How do we implement multiple parameters within an effect?\par
At first, we don't care; there is only one float per effect.\par
But eventually we do have multiple.  Do we have actual Parameter subclasses?\par
NO we don't.\par
\par
\par
BUT WE DO need stateful Effect classes!  Because some effects actually have their own FX handles!\par
So AllEffects really is a Type -> EffectFactory map.\par
And we \i do\i0  need EffectSet.\par
And then we can apply an EffectSet to a ParameterSet.\par
\par
\par
...eventually we really want Envelopes, so we can just save one or two numbers (the parameter axis values) and interpolate many other parameter values from them.  Much more efficient on space.  \line THE GOAL: to avoid space duplication from\par
- multiple tracks needing effects with the same parameters (don't want to store identical data per-track)\par
\tab - this implies that parameters, once associated with a track, become immutable and therefore sharable\par
- multiple parameters that are all interpolated from the same parameter UI values\par
\tab - in other words, if the X axis is interpolating between 10 parameters, don't want to save all those interpolated values; cheaper to recalculate (space-wise, anyway)\par
\par
BUT this is complication for another day.  Right now we only have a couple so let's just copy them.  And fuck it, let's not worry about the immutability either; not enough parameters for it to matter yet.\par
\par
Hmm.  But these need to be updatable after the fact.\par
Well, that's easy; you just replace any given Parameter in the ParameterSet with a new immutable shared one.\par
\par
FOR NOW, the Microphone ParameterSet is mutated like crazy and applied per-Kinect-update.  (watch out for threading issues....)\par
When the track is forked, the Microphone ParameterSet is cloned.\par
...what is the policy around the Microphone ParameterSet?\par
\tab - it must be complete since it could have been arbitrarily effected.\par
\tab - let's assume that setting parameters on tracks DOES NOT affect the microphone parameters.\par
\tab\tab - then you can moan eerily while frobbing other stuff too.\par
\par
OK, so the Microphone ParameterSet is complete.\par
The Parameter UI side-effects the Microphone ParameterSet.\par
\par
If there is a set of selected tracks, the Parameter UI \i puts the Microphone's mutable Parameter instances directly into those ParameterSets.\i0\par
\par
But then what does it do once the A button comes up?  It needs to copy the existing Parameters, and replace all the pointers in the Tracks' ParameterSets with the copied ones.  OK, so we DO need Copy.  But during effect wiggling, we can just mutate the shared one.  That's pretty nice actually.\par
\par
\par
Alrighty, that works, but ran out of gas tonight.  At least all the effect/parameter infrastructure is there now :-)  Should be able to get the rest in about three hours on Saturday morning... then two hours of testing and dinking, then off to Heden!\par
\par
- multiple monitor support\par
\tab - get git - \b DONE\b0\par
\tab - check out sharpdx sources - \b DONE\b0\par
\tab - install dxsdk - \b DONE\b0  but might need to redo, redistributables complained\par
\par
\par
- research SharpDX Toolkit\par
\tab - specifically SpriteBatch and PNG loading\par
\tab - nope can't do it yet\par
\par
- can't load SharpDX.sln in VS2010, so VS2012 RC1 ahoy!!!  time to catch up with the rest of the world :-D\par
\tab - install \b DONE\b0\par
\par
\par
\par
DONEDATE 2012/07/23:\par
\par
- try converting holofunk to ANX\par
\tab - seems mostly OK but content project is fubar\par
\tab - ANX doesn't seem to support loading PNGs; need to save as 32-bit RGBA (how???)\par
\tab - pixelformer to the rescue!!!  looks like maybe that works.\par
\par
OK enough for tonight SHEEEESH.\par
\par
\par
- check laptop to make sure can run DX11!!!\par
\tab - ack, how to do that???\par
\tab - dxdiag says it's DX11\par
\tab - but multicubetexture sample doesn't run\par
\tab - install dxsdk, get dx debugging working\par
\tab - \b DONE\b0\par
\par
- ask online about ANX texture loading - \b DONE\b0\par
\par
- ask about SharpDX texture loading too, for that matter\par
\tab - never mind, there are all kinds of things!  Texture2D.Load ferpetesake!\par
\tab - yay r8g8b8a8 works!\par
\par
- try building SharpDX from source - \b FAIL\par
\b0\par
- modify SharpDX sample to have two windows\par
\tab - show proof of concept of multiple windows w/SharpDX (risk assessment; is the easy version easy?)\par
\tab - \b DONE!!!!!\b0\par
\tab - kind of insanely easy!\par
\tab - AFTER, that is, \par
\tab 1) turning on unmanaged code debugging\par
\tab 2) using dx control panel to enable dx debugging for MultiCubeTexture.exe\par
\tab 3) hitting some kind of "unable to debug mixed mode with .NET 2.0" error\par
\tab 4) going to solution properties and then Configuration Manager, adding x86 configuration\par
\tab 5) \b WIN.\b0\par
\par
\par
- test loading PNG texture into MultiCubeTexture\par
\tab - \b FAIL\b0  - looks like shit\par
- test loading 32-bit BMP into MultiCubeTexture\par
\tab - \b WIN!!!!!\b0   looks fucking perfect!!!!   OH YAY!\par
\par
\par
wow, that's a great stopping place!!!\par
\par
\par
OH JOY FOUND WINDOWS FORMS + XNA EXAMPLE!!!!!\par
so far so good, looks like it will be ok....\par
\par
- test Windows Forms + XNA hack job\par
\par
- add in support for multiple Holofunk windows\par
\tab - split out HolofunkForm class\par
\tab - HolofunkForm takes a scene graph and an "orientation"\par
\par
\tab - apply orientation when traversing scene graph\par
\tab - test out negative scale to see if it mirrors (GOD I HOPE SO)\par
\par
\tab - HolofunkForm just draws itself in its Draw()\par
\par
\tab - how do we get repeated Draw()s???\par
\par
then Holofunk class gets all the actual game state.\par
\par
\par
DONEDATE 2012/10/18:\par
\par
\par
ugh.  do we want those to be different from the ones associated with the selected loopies?  would that be too confusing?\par
\tab - but the selected loopies will in general have MULTIPLE PARAMETER VALUES!\par
\tab - so what do we do about THAT?  what if you want to affect parameters INDIVIDUALLY?\par
\tab - maybe each crosshair direction selects ONE parameter, exclusively.  at first.\par
\tab - then can add menus etc. to increase the functionality\par
\tab - so you see one parameter-square per selected track, and you can set them all at once\par
\tab - and you can avoid fucking up any parameters you don't want to touch.\par
\par
CROSSPAD IS FOR PRESETS.\par
generalized assignment of parameters to axes / postures.\par
preset determines if you're affecting just one or multiple axes when you hold down A.\par
\par
tap A briefly to bring up menu???\par
\par
\par
THEN WHAT ABOUT FRIGGIN' SELECTION / MUTATION?\par
\par
problem is that I don't want to use the trackpad, it's too horrible.\par
\par
So.  Selection is already covered, more or less -- either cursor contact, or whole region.  Let's pretend that's enough.\par
\par
Then, we have three actions the user can take:\par
- Choose a type of effect.\par
- Actually manipulate with that effect.\par
- Choose to record the manipulation, or not.  (eventually)\par
\par
And I don't want to use the pad for direct manipulation.  Irrational instinct.\par
\par
So, how about this?  OPTIONALLY, A button, tapped, causes selection.  A button, held, pops menu.  \par
\par
Once manipulation is selected, the A button, held down, performs manipulation (and tapped, selection).  Home button returns to state with no manipulation active.\par
\par
(The reason we need an explicit selection gesture is that manipulation takes over positioning; positioning is then for effect purposes, not for loopie placement or implicit selection purposes.)\par
\par
Deselection is \i implicitly done when the mike is raised.\i0   When the mike is near the mouth, the A button serves to \i manipulate the mike\i0  with the currently selected effect, and the trigger, as usual, makes a new loopie.  YES BEAUTIFUL, can manipulate while recording with A and trigger, though you'd better wind up in the right place on screen!\par
\par
(Otherwise, deselection can be done with Home again in a plain-cursor state.)\par
\par
- add mike-to-head proximity, to trigger record dot inside hand cursor\par
\tab - this is an effect that exists only in normal mode\par
\par
LATER INTERACTIONS:\par
\par
- moving over loopie makes it respond (change color, at first)\par
- pressing A on loopie makes it respond again (white circle surround???)\par
- holding A on loopie lets it be dragged\par
- releasing A drops loopie but leaves it selected\par
\par
- A on background unselects loopies\par
\par
\par
\par
- minus button mutes a quadrant, plus button unmutes\par
\par
- crosspad triggers effects\par
- wave arm while crosspadding to apply effect in realtime\par
- trigger plus crosspad makes effect persistent\par
\tab - how do you make mike effect persistent?\par
\tab - do trigger plus crosspad with nothing selected?\par
\tab - no, select mike!!!  why not.\par
- trigger plus crosspad with something selected causes the dynamic modification to get recorded\par
\par
two-player work;\par
\par
- actually try two Wiimotes for the first time - \b DONE!\par
\tab - \b0 shit Nyko ripoff doesn't work, only the REAL NINTENDO DEAL.\par
\tab - ok, time to get like three more....\par
\par
\par
- support two Holofunk state machines - \b DONE\b0\par
\tab - tricky part: what if two actions affecting same tracks?\par
\tab\tab - don't EVEN worry about it... yet\par
\par
- support two Wiimotes - \b DONE\b0\par
\par
refactor ALL the code:\par
\par
- support PlayerSceneGraph - \b DONE\par
\par
- TEST - DONE\b0\par
\par
- support two Kinect player input channels - \b DONE\b0\par
\par
- figure out all the player entry/exit/side-switching logic\par
\tab - modes: 1-player-only; 1-player, static-second-player; 2-player, fully dynamic\par
\tab - \b DONE\b0\par
\par
- support two ASIO input channels - AsioInput, multiplexed into single BassAsio handler(?) - \b DONE\b0\par
\par
- \b TEST - \par
\par
W T F is up with this stack\par
\b0  \tab [External Code]\tab\par
 \tab Holofunk.exe!Holofunk.PlayerState.HandRegion.get() Line 201 + 0x1b bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.PlayerSceneGraph.Update(Holofunk.PlayerState playerState = \{Holofunk.PlayerState\}, Holofunk.Kinect.HolofunKinect kinect = \{Holofunk.Kinect.HolofunKinect\}, Holofunk.Core.Moment now = \{Holofunk.Core.Moment\}) Line 185 + 0x10 bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.HolofunkSceneGraph.Update(Holofunk.HolofunkState holofunkState = \{Holofunk.HolofunkState\}, Holofunk.Kinect.HolofunKinect kinect = \{Holofunk.Kinect.HolofunKinect\}, Holofunk.WiimoteController wiimote = \{Holofunk.WiimoteController\}, Holofunk.Core.Moment now = \{Holofunk.Core.Moment\}, long tickCount = 115, long totalTickCount = 171880000) Line 388 + 0x44 bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.Holofunk.UpdateWorld() Line 332 + 0x8f bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.Holofunk.Tick() Line 273 + 0x8 bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.Holofunk..ctor.AnonymousMethod__0() Line 90 + 0x9 bytes\tab C#\par
 \tab [External Code]\tab\par
 \tab Holofunk.exe!Holofunk.Holofunk.Initialize.AnonymousMethod__2() Line 140 + 0x16 bytes\tab C#\par
 \tab Holofunkinect.dll!Holofunk.Kinect.HolofunKinect.Kinect_AllFramesReady(object sender = \{Microsoft.Kinect.KinectSensor\}, Microsoft.Kinect.AllFramesReadyEventArgs e = \{Microsoft.Kinect.AllFramesReadyEventArgs\}) Line 189 + 0xe bytes\tab C#\par
 \tab [External Code]\tab\par
 \tab Holofunk.exe!Holofunk.PlayerState.HandRegion.get() Line 201 + 0x1b bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.PlayerSceneGraph.Update(Holofunk.PlayerState playerState = \{Holofunk.PlayerState\}, Holofunk.Kinect.HolofunKinect kinect = \{Holofunk.Kinect.HolofunKinect\}, Holofunk.Core.Moment now = \{Holofunk.Core.Moment\}) Line 185 + 0x10 bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.HolofunkSceneGraph.Update(Holofunk.HolofunkState holofunkState = \{Holofunk.HolofunkState\}, Holofunk.Kinect.HolofunKinect kinect = \{Holofunk.Kinect.HolofunKinect\}, Holofunk.WiimoteController wiimote = \{Holofunk.WiimoteController\}, Holofunk.Core.Moment now = \{Holofunk.Core.Moment\}, long tickCount = 114, long totalTickCount = 169830000) Line 388 + 0x44 bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.Holofunk.UpdateWorld() Line 332 + 0x8f bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.Holofunk.Tick() Line 273 + 0x8 bytes\tab C#\par
 \tab Holofunk.exe!Holofunk.Holofunk..ctor.AnonymousMethod__0() Line 90 + 0x9 bytes\tab C#\par
 \tab [External Code]\tab\par
 \tab Holofunk.exe!Holofunk.Holofunk.Initialize.AnonymousMethod__2() Line 140 + 0x16 bytes\tab C#\par
 \tab Holofunkinect.dll!Holofunk.Kinect.HolofunKinect.Kinect_AllFramesReady(object sender = \{Microsoft.Kinect.KinectSensor\}, Microsoft.Kinect.AllFramesReadyEventArgs e = \{Microsoft.Kinect.AllFramesReadyEventArgs\}) Line 189 + 0xe bytes\tab C#\par
\par
\par
That is some bullshit right THERE.  OK fine, let's NOT make the Kinect drive everything.\par
\par
alright, it was because m_inputPushEffects was uninitialized, causing assertion dialogs, causing re-entrant Kinect callbacks.  Root issue was StartASIO was NEVER called on the HolofunkBassAsioInput.  Moving that whole routine into the HolofunkBassAsioInput constructor made it happy at least somewhat.  Let's checkpoint.\par
\par
\par
- hack using the right ASIO input channel\par
\tab - experiment and find out how the hell it actually works\par
\par
- DEBUG THE SHIT OUT OF IT\par
\tab - \b WORKS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\b0\par
\par
\par
\par
- bring fixes back over\par
\tab - remove bogus assertion around player mode when second skeleton found\par
\tab - spam console write locked it up\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
\par
DONEDATE 2012/12/08:\par

\pard\f0\fs20\lang1033 OK HERE IS THE FINAL INTERACTION PLAN FOR EFFECTS AND MENUS AND EVERYTHING, VERBALLY.\par
screw updating Visio, it's not worth the time.\par
\par
RESEARCH GREENSCREEN SAMPLE IN K4W SDK 1.6\par
\par
\par
\par
SHARPDX EXPERIMENTS:\par
\par
NORMAL MODE\par
\b - touch crosspad: select effect preset (no dynamic effect)\par
- hold crosspad: pop up effect selection menu for that direction\par
\b0 - hold trigger: start recording new sound\par
\tab - \b if previous track still finishing its duration, pad it immediately with silence and start new track as usual\par
\b0 - hold minus / plus: enter mute / unmute mode\par
\b - press A: lock selected tracks (or mike), enter effect mode\par
- hold home: pop menu\par
- hold hand next to mike (ONLY WHILE IN NORMAL MODE, NO MUTE/UNMUTE/ETC): select mike \par
\tab such that A will lock mike for selection mode\par
\tab and crosspad will start applying effects to mike\par
\b0\par
MUTE/UNMUTE MODE\par
- mute/unmute tracks you move over or select\par
- release button: back to normal mode\par
\par
\b MENU MODE\par
- while home held: navigate menus\par
- home up: select menu item\par
\b0\par
\b EFFECT SELECTION MENU\par
- same as menu mode\par
\tab - select effects on each axis\par
\tab - maybe same set of effects in each direction just for symmetry...?\par
- crosspad up: select effect preset\par
\b0\par
RECORDING MODE\par
- while trigger held: recording new track\par
\tab - hand position: track placement\par
- let up trigger: \b track finishes recording out to its preselected length, in Normal mode\par
\b0\par
\b EFFECT MODE\par
- hold down A: apply and modify effect parameters (X / Y only at first) on selected tracks (or mike)\par
- hold down trigger while holding A: effect recording mode\par
- press home: return to normal mode\par
\par
EFFECT RECORDING MODE\par
- let go of A: back to normal mode\par
- let go of trigger: back to effect mode, commence looping parameters (even if A still held)\par
\par
\b0\par
LOOPING MODEL FOR PARAMETERS\par
- generalized parameter space\par
- each parameter can be driven by an independent track\par
- mapping of track to parameter is purely dynamic\par
\par
soooo, when you start recording:\par
- sample X/Y position\par
- record which parameters are correlated to which position\par
\par
what's the \i abstraction?\i0\par
the abstraction is:  there are ParameterTracks that semantically are time -> [ParameterValue] functions.\par
when you start effect recording, you create a new ParameterTrack for the parameters in the current preset.\par
If those parameters supersede one or more current ParameterTracks, then you can reclaim those the moment you make the new ParameterTrack.\par
\par
That way we can overlay short loops, etc., on top of longer underlying parameter loop cycles.\par
\par
\par
APPLYING EFFECT WHEN TOUCHING CROSSPAD\par
- should all effects have wet/dry levels as one axis?  maybe Z?????\par
- and what about the goddamned edge-of-the-area problem?\par
\tab - namely, that the position on the screen at which your selected tracks exist may limit the starting parmeter value.\par
\tab - switching coordinate mappings from purely spatial selection over to parameter space.\par
\par
sooooo, what should happen?  \i tap\i0  A to enter effects mode on the given selection?  \par
\tab yyyyyes, let's say so.\par
\tab then once you're \i in \i0 effects mode, \i holding A\i0  actually \i applies\i0  the effect.  the first tap locks in your selection set.\par
\tab that means it works well for the microphone too.\par
\par
can you record a track \i and\i0  effect it simultaneously???\par
\i\tab not with this interface, not at first.\i0\par
\tab let's get this working and then see what new insight prevails.\par
\par
\par
\par
- quickly try out the pan fix suggested online\par
- hook up volume in effects UI, at least!\par
\par
\par
\par
RESEARCH VST\par
\par
\par
\par
next:\par
- mung MultiCubeTexture to simply render flat squares (circling slowly or something)\par
\par
- think about how to restructure holofunk scene graph to support distinct resources per form\par
\par
\par
\par
chorus and echo:\par
\f3\fs16 _fxChorusHandle = \cf2 Bass\cf0 .BASS_ChannelSetFX(_Stream, \cf2 BASSFXType\cf0 .BASS_FX_DX8_CHORUS, 1);\par
_chorus.fWetDryMix = 0f;\par
trackBarChorus.Value = 0;\par
\cf2 Bass\cf0 .BASS_FXSetParameters(_fxChorusHandle, _chorus);\par
\par
_fxEchoHandle = \cf2 Bass\cf0 .BASS_ChannelSetFX(_Stream, \cf2 BASSFXType\cf0 .BASS_FX_DX8_ECHO, 2);\par
_echo.fWetDryMix = 0f;\par
trackBarEcho.Value = 0;\par
\cf2 Bass\cf0 .BASS_FXSetParameters(_fxEchoHandle, _echo);\par
\f0\fs20\par
\cf6\f3\fs16 // 3-band EQ\par
\cf2 BASS_DX8_PARAMEQ\cf0  eq = \cf1 new\cf0  \cf2 BASS_DX8_PARAMEQ\cf0 ();\par
_fxEQ[0] = \cf2 Bass\cf0 .BASS_ChannelSetFX(_Stream, \cf2 BASSFXType\cf0 .BASS_FX_DX8_PARAMEQ, 0);\par
_fxEQ[1] = \cf2 Bass\cf0 .BASS_ChannelSetFX(_Stream, \cf2 BASSFXType\cf0 .BASS_FX_DX8_PARAMEQ, 0);\par
_fxEQ[2] = \cf2 Bass\cf0 .BASS_ChannelSetFX(_Stream, \cf2 BASSFXType\cf0 .BASS_FX_DX8_PARAMEQ, 0);\par
eq.fBandwidth = 18f;\par
\par
eq.fCenter = 100f;\par
eq.fGain = \cf1 this\cf0 .trackBarLowEQ.Value / 10f;\par
\cf2 Bass\cf0 .BASS_FXSetParameters(_fxEQ[0], eq);\par
eq.fCenter = 1000f;\par
eq.fGain = \cf1 this\cf0 .trackBarMidEQ.Value / 10f;\par
\cf2 Bass\cf0 .BASS_FXSetParameters(_fxEQ[1], eq);\par
eq.fCenter = 8000f;\par
eq.fGain = \cf1 this\cf0 .trackBarHighEQ.Value / 10f;\par
\cf2 Bass\cf0 .BASS_FXSetParameters(_fxEQ[2], eq);\par
\f0\fs20\par
and every other damn one in BASSFX!\par
\par
\par
(then: graphical rendering of the pan effect)\par
(then: graphical rendering of the other effects)\par
(then: timed parameters)\par
\par
\par
(and of course you could let people move tracks around, perhaps with the unused 1/2 buttons?!?!?!  that could help with the "recording envelope and audio at same time" issue)\par
\par
\par
- mute becomes delayed command, to take effect at next... what?  measure?  beat?  let's say measure\par
\par
\par
- don't bother yet with gray background\par
\par
- A button down sets rewind point for currently selected tracks\par
\tab - cursor goes to rewind cursor as long as any of those tracks are in TouchedTracks\par
\tab - those tracks remain highlighted until TouchedTracks no longer contains any of them\par
\tab - subsequent A button downs cause those tracks to revert to that point\par
\tab - until user moves arm away from ALL those tracks; then tracks resync at next loop point\par
\tab - add double-triangle rewind icon in that case\par
\par
- separate spammer thread altogether\par
\par
\par
- collect many heavy statistics\par
\tab - average FPS in last N frames\par
\tab - msec per Kinect frame\par
\tab - msec per Kinect dispatch activity\par
\par
\par
- NEW INTERFACE TWEAKS:\par
palette state: d-pad quick press chooses that direction's preset; prolonged hold goes to Preset Selection.\par
\par
TECHNICAL TERMS:\par
\par
Preset: a parameterized Interaction.\par
\par
Interaction: a particular interface for manipulating some Parameters and/or generating input sound.  \par
Examples: the Palette interaction is the default "circular loopies, spatially static, space mapped to grouping"; the Parameter interaction is "parameter mode", "space mapped to X/Y knobs, which are in turn mapped to (sets of) min/maxable Parameters"\par
\par
The Parameter interaction furthermore allows \par
\par
\par
Preset is typically an entire Effect, with some saved initial parameter values.\par
\par
Effect Wipe state:\par
- sets the Effect Wipe preset UNTIL THE NEXT D-PAD PRESS.\par
\par
Effect Wipe preset behavior:\par
- 1 resets the mike to no effects.\par
- A resets the touched loopies to no effects.\par
\par
\par
What is this "preset behavior"?\par
Answer: Palette interaction has a Preset as part of its state.\par
Preset can be used to look up a State to transition to?!?!?!?!\par
hmmmmm.\par
\par
Let's make them be sub-states.  So PresetState is a sub-state of PaletteState, and so is EffectWipeState.  That actually makes sense.\par
\par
Parameter state is on the other hand unrelated to PaletteState, totally different interactions etc.\par
\par
\par
(Don't do Widgets yet... Interactions are not yet composable....)\par
\par
\par
Parameter state:\par
- Initially shows \i all\i0  the parameter values of the touched loopies.\par
\tab - No.  IIf it is a preset then it must get applied at some point.\par
\tab It might even be an animated preset!  In which case the act of\par
\tab\i entering the preset\i0  must also apply the preset parameters to\par
\tab the selection set.  Otherwise the user has the impossible task\par
\tab of replicating the animation just in order to assign it!\par
- (Eventually) A + trigger records animated envelope.\par
\tab - This can of course be made into a preset.\par
- D-pad press up/down vs. left/right allows rotating through the parameters on either axis.\par
\tab - Maybe display the next ones?\par
- D-pad hold brings up selection.\par
- 1 applies the current parameters to the microphone (additively with priority).  (or removes the microphone from the effected set)\par
- Home WIPES the current parameters?  No, that doesn't really work.  Home returns out of parameter mode, duh.\par
\par
\par
\par
STATES GET THE UPDATE FUNCTIONS DIRECTLY.\par
STATES CAN CALL THE UPDATE FUNCTIONS OF OTHER STATES?!?!?!\par
\tab "parent" state?\par
\par
\par
HOW DO YOU DO MULTIPLE EFFECTS THIS WAY?\par
- Set up both effects (effects continue)\par
\tab - How do you REMOVE an effect?\par
\tab\tab - NORMAL PRESET!\par
\tab\tab - just one more preset.  Has no effects at all.\par
\par
But what is the model of parameter sets?  Purely additive?  Prioritized?  Would have to be prioritized, for sanity's sake.  In what order?  The order of application?  Presumably, yes....\par
\par
Then how do we describe a NEGATIVE parameter set?  That is, the "No Effects" preset, that removes (rather than combining with) existing effects?\par
\par
Hmm, would seem you should be able to indicate that a parameter set transitioned from populated to empty.  In other words, rebind the associated loops to empty parameter sets at that time.  And it's a (transient) STATE, not a mere parameter set.\par
\par
\par
\par
\par
- ensure static initializers actually all run before MicrophoneParameters gets initialized!  (and ensure MikeParameters initialized properly\par
\par
- Define MicrophoneTouched flag and interaction\par
\tab - aaaah, really sucky how bad the hand position recognition is!!!  can't use hand distance reliably!\par
\tab - so, what then?  A to enter parameter mode is fine for anything you're touching.  But can't use hand 2D proximity to face because might want to be knobbing a loopie that's right in front of your face.  \par
\tab - FUCK IT.  Use the 1 button to set the microphone parameters, totally independently.  Can enter parameter mode with mike ONLY selected, anytime.\par
\tab - dammit why Kinect 2 doesn't do much better?  oh well, KEEP THE WIIMOTES!!!  and BUY MORE.  ... but won't scale into the future.  Oh well, ANY damn clicky remote-like thing will work.\par
\tab - if Kinect 2 gets hand distance reliably and open/closed hand pose, can probably do a lot with that.\par
\tab - DONE???\par
\par
- Copy the microphone effects when starting a new track.\par
\tab - DONE?????????\par
\par
\par
- Plug in as many BASS effects as are easy to enable (phaser, flange, reverb....)\par
\tab - HALF DONE\par
\par
\par
\b THEN TIME TO RESEARCH VST!!!!!!!\b0\par
\par
\par
Then implement region effects:\par
- actual Region class?  yeah why not\par
\tab - Region has its ParameterSet\par
- PlayerState.MicrophoneRegion\par
- each Loop has an associated Region\par
- there's a WiiHandRegion\par
- entering parameter mode sets the region parameters on the current WiiHandRegion\par
\tab - and propagates them to the microphone parameters and all the Loopies in the Region\par
\tab - NO NO NO, the loopies know their region and \i reference the parameters in it\par
\i0\par
each Loopie has its own LoopParameterSet and a reference to its Region, which has a RegionParameterSet\par
...yes, that's consistent.\par
\par
then:\par
- VST support FINALLY!\par
\par
\par
\par
\par
EVENTUALLY:\par
- Visio-like dynamic group/ungroup\par
- in other words, DYNAMIC USER-EDITABLE REGIONS\par
- each dynamic group becomes a VST instance\par
- let the user build their VST hierarchy and maybe even REORDER it\par
- SUPER SWEET, DUDE!\par
\par
\par
BLOG:\par
{{\field{\*\fldinst{HYPERLINK http://www.djtechtools.com/2012/12/12/the-beardytron-5000-mkii-building-beardymans-ultimate-live-production-system/#disqus_thread }}{\fldrslt{http://www.djtechtools.com/2012/12/12/the-beardytron-5000-mkii-building-beardymans-ultimate-live-production-system/#disqus_thread\ul0\cf0}}}}\f0\fs20   HELL YESSSSS\par
\par
{{\field{\*\fldinst{HYPERLINK http://www.youtube.com/watch?v=bCC9uHHAEuA&#t=10m55s }}{\fldrslt{http://www.youtube.com/watch?v=bCC9uHHAEuA&#t=10m55s\ul0\cf0}}}}\f0\fs20  awesomely inspiring\par
\par
\par
- FUN STUFF\par
\tab - silly volume-sensitive faces for audience view, based on averaged volume - \b DONE XD\b0\par
\par
\par
- fix bugs/annoyances:\par
\tab - subzero BPM crashes - \b DONE\par
\tab - \b0 fix loopies showing beats on secondary view - \b DONE\par
\tab - \b0 make second hand rectangle go away when no second player - \b DONE\b0\par
\par
UPGRADE TO SHARPDX:\par
- switch to Net40Debug not DIRECTX11_1 (which is not supported on Win7, time to upgrade there too) - \b DONE\b0\par
\par
\b OMG OMG OMG OMG OMG!!!  SPRITEBATCH SAMPLE RIGHT OUT OF THE BOX!!!!\par
\b0 need to add multi window support though.  will investigate.  Per-Window Draw, I think?  something like that? - \b DONE\b0\par
\par
- convert all Holofunk to build with SharpDX - \b DONE\par
\b0 - get Holofunk up on screen with dual SharpDX windows - \b DONE\par
\b0 - fix Kinect texture rendering - \b DONE\par
\b0 - fix other sprites - \b DONE\b0\par
\par
very simple effects system:\par
\tab - "pan/fade" - hold A and move left/right \par
\tab - "volume" - top is max, bottom is silent\par
\par
\b YAY IT WORKS FOR MICROPHONE\b0\par
\par
- WIRELESS MIKES?!  with RCA *out*?!\par
\par
TWO CATEGORIES OF EFFECT: PER-LOOP AND PER-REGION.\par
No reason volume and pan can't be per-loop and may have others as well, it's cheap if you don't have to instantiate a mega-VST.\par
But for mega-VST effects we make them per-region.\par
\par
HOW TO SET THE ACTIVE MICROPHONE EFFECT?\par
Simple:  for region effects, there is a mike icon in the current region affecting the mike, and tweaking the parameters in that region tweaks the mike as well.\par
Starting a loop in a region instantly inherits the active region effect parameters IN THAT REGION.\par
\par
For per-loop effects... speculative here... holding the WIIMOTE HAND NEXT TO THE MIKE HAND AT THE MOUTH is how to control the active parameter on the mike.\par
Starting a loop instantly inherits the active per-loop effect parameters ON THE MICROPHONE.\par
\par
This seems to give the greatest possible granularity at the cost of \i severe confusion.  OH WELL. MUST PROTOTYPE.\i0\par
\par
Complexity o' the evening:  requirements tension.\par
- Zero-allocation update of parameters being manipulated in the UI, across all touched loopies & the mike.\par
- Minimal-allocation copying of parameters at the end of parameter manipulation, across all touched loopies & the mike.\par
- Create new parameters corresponding to parameter UI; only change them when UI parameter dimensions change.\par
\par
So, we have the UIParameters, which is the set of parameters selected in the current UI, along with their values.  Once we have parameter recording, this becomes the currently recorded parameter "tracks".\par
\par
Then we have the MicrophoneParameters and LoopParameters, which share the mutable UIParameters until such time as the UIParameter \i dimensions\i0  change, at which point the UIParameters get copied and \i the copies get shared with all relevant Loopies/Mikes.  \i0 That's the key: there is \i one\i0  immutable Parameter copy, that is shared by all other parameter sets.  And actually it's set up well for that, go me!\par
\par
OK, that makes sense and is pretty straightforward.\par
\par
\par
Soooo, now what? \par
- EffectGranularity - Loop, Region - \b DONE\b0\par
- Effect has EffectGranularity - \b DONE\b0\par
- Can get a ParameterSet for all Loop effects - \b DONE\b0\par
- Instantiate per-Loop effects for each Loopie, and for the microphone \b - DONE\b0\par
- Parameter mode applies any current Loop effect parameters to the set of TouchedLoopies - \b DONE\b0\par
\par
- TEST IT - \b DONE!!!!!!\b0\par
\par
- Copy the current loop value to parameter mode when entering it\par
\tab ...what if there are multiple different values?  WEIGHTED AVERAGE, WHY NOT, NOTHING BETTER IS POSSIBLE\par
\tab - \b DONE\b0\par
\par
- Add echo effect!\par
\b\tab - DONE\b0\par
\par
- Add text labels for dimensions.\par
\b\tab  - DONE\par
\b0\par
- D-pad interaction to switch dimension effects\par
\b\tab  - DONE\par
\b0\par
HOLEE SHIT WORKING FIRST TIME.\par
parameters map one to one to knobs on the screen, reading left to right by row, top to bottom.\par
the big knobs are the Controls.\par
FX1 is effect 1, on through 8.\par
duplicate parameter names are because it is under the same label in two different rows, e.g. all the duplicated ones at the bottom for the top / bottom knobs.\par
Don't really know what "FX G" is at the bottom... ah it's probably gain!!!  NIIIIICE\par
\par
OK so let's go\par
\par
Huh, what are those program names???\par
-\tab\tab programNames\tab\{string[16]\}\tab string[]\par
\tab\tab [0]\tab "AbnormalBreak"\tab string\par
\tab\tab [1]\tab "Audioschnitzel"\tab string\par
\tab\tab [2]\tab "Beat It"\tab string\par
\tab\tab [3]\tab "Beef"\tab string\par
\tab\tab [4]\tab "DestroyMusic"\tab string\par
\tab\tab [5]\tab "Dictate It"\tab string\par
\tab\tab [6]\tab "Dictate Me"\tab string\par
\tab\tab [7]\tab "Director"\tab string\par
\tab\tab [8]\tab "Earbleed"\tab string\par
\tab\tab [9]\tab "Filterstop"\tab string\par
\tab\tab [10]\tab "InTheArena"\tab string\par
\tab\tab [11]\tab "Keyable"\tab string\par
\tab\tab [12]\tab "Maestro"\tab string\par
\tab\tab [13]\tab "Mega Aua"\tab string\par
\tab\tab [14]\tab "TheMoLoop"\tab string\par
\tab\tab [15]\tab "Trico"\tab string\par
\par
Ah, it's only the first 16!  What about the rest???\par
\par
HOLY SHIT, SELECT "PRESETS BY BEARDYMAN" ?!?!?!?!?!?!!?!?!?!?!?!?!?!\par
\par
is there any way to get to those from the VST interface?  HMMMMM\par
\par
\b DICTATOR MODE IS JUST AN INTERACTION. \par
\b0\par
\par
\b AWWWW HEEEELLL YEEEEEAAAAAHHHHH\b0\par
looks ready to go as soon as I get a few basic clues!!!  TOMORROW!!!!!\par
\par
\b - TRY TURNADO!!!!!!!\par
- \b0 ARRRRRGH, SETPROGRAM DOESN'T WORK AT ALL.\par
\tab - so can't load the preset that I want.\par
\b\tab - W T F\par
\b0\tab - I was just impatient :-D  \b\i IT WORKS!!!!!!!\b0\i0\par
\par
Next time:\par
- call ChannelSetDSP from somewhere other than the audio thread, somehow\par
\tab - avoid taking the loading hit in the audio thread\par
\tab - YESSSS, CACHING THEM UPFRONT WORKS AAAAWESOMELY\par
\tab - \b DONE\b0\par
\par
\par
Damn slice arranger tempo drift.\par
- Holofunk is clocked accurately vs. metronome.\par
- Turnado playing its own sound player is clocked accurately vs. metronome.\par
- Holofunk driving Turnado is NOT clocked accurately.\par
- Does Turnado expect 44.1Khz incoming sample rate where Holofunk is giving 48Khz?\par
\tab - Tried clocking Holofunk at 120Hz and Turnado at 110.25Hz (= (44100 / 48000) * 120)\par
\tab - Turnado still JUST SLIGHTLY too fast.  But MUCH closer.\par
\tab - Then try Turnado at 105Hz... nope still too fast, but CLOSER YET\par
\tab - Then at 100Hz... JUST NOT HEARING THAT MUCH DIFFERENCE, ARRRRGH\par
\par
98bpm seems to be aligned perfectly at 3/4 time.\par
So, try 4/3 * 98 = 130 & 3/4 * 98 = 73.5\par
\par
O HO.\par
130.612 = 48000 / 44100 * 120\par
and that seems to be the perfect speed for SliceWarz.\par
WHAT DOES IT MEAN, NO ONE CAN KNOW\par
oh wait oh wait!!!  maybe the tempo is saved in the program!!!!!!!!!!!!!!!!!!\par
THEN IT MAKES SENSE, HALLELUJARHAHARAH\par
\par
\b\i OH HOLEEEEEEE SHIIIIIT YEEEEEEEAH\b0\i0\par
\par
\par
\par
- fix home so it wipes effects when pressed on existing tracks!!!!!  YES YES YES of course.\par
\tab - wanna clean up, just minus-minus-minus\par
\tab - wanna clean up the mike effect... what do you do???  \par
\tab\tab - can't push home while in "mike-parameter mode"\par
- OK fine.  Quick press of home gets you out of mike-parameter mode.  LONG HOLD of home resets mike parameters (and dumps you out).  So, press 1, hold home (for two beats), and bob's your uncle.\par
\b\tab - DONE!!!\b0\par
\par
- get the microphone interaction sorted out\tab\par
\tab - push 1 from palette state, go into parameter mode for mike only\par
\tab\tab - push A from parameter mode in that situation = nothing happens\par
\tab - push 1 from loop-parameter state: add/remove mike to/from parameter mix\par
\b\tab - DONE!!!\b0\par
\par
- Beat events should be delivered an even number of beats after the time the last state was entered!\par
\tab - That way you always know exactly how long to hold it from the start time.  HOLD FOR ONE BEAT has its precise meaning.\par
\tab - So the state should know its precise time of entry and on beat events (or whenever) should be able to query for BeatsSinceStateEntered.  EASY PEASY and very deterministic.  YAY\par
\b\tab - DONE!!!\b0\par
\par
- make parameter mode support D-pad rotating through effects\par
\tab - only pushes effect values when A (or 1) were actually pressed in parameter mode\par
\tab - so can cycle through without affecting anything (absent positive button press)\par
\b\tab - DONE!!!  ???\par
\b0\par
- two-player parameter mode\par
\tab - player 1 always the square on left, player 2 on right\par
\tab\tab - unless only one player mode (not dynamic, static)\par
\tab - player 1 blue, player 2 green (or whatever)\par
\b\tab - DONE!!!\b0\par
\par
- tweak the text positions & sizes a bit\par
\b\tab - DONE!!!\b0\par
\par
\b READY FOR DEMO AT THAT POINT\b0\par
\par
\par
STATE STATE:\par
- states should be able to have their own mutable state (timers, etc)\line - scoped to that state for its lifetime (and perhaps as long as the occupied state is a child)\par
\tab - nice to have access to parent state state\par
- touched loopies would fall into this category\par
\tab - potentially "parameter mike" might as well, not sure yet\par
- nah, do state bags\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
\par
DONEDATE 2013/03/23:\par

\pard\f0\fs20\lang1033 CHOP UP THE PLAYERSTATE - \b DONE\b0\par
\par
\f1 -\tab Concurrent modification of m_loopies list\par
\f0\tab\tab hmm, really a lot of places touch it....\par
\tab\tab but only one place modifies it off the game thread.  ok then.\f1\par
\f0\tab\tab\b DONE\b0\par
\par
- how to measure text?\par
\tab - ta-da!  SpriteFont.MeasureString!  easy mcpeasy\par
\tab - ok so let's do MenuItemNode\par
\tab - actually let's just do it in TextNode and add an origin???\par
\tab - \b DONE\b0\par
\par
\b HOW TO DO THIS THING?\b0\par
answer: \par
\par
- implement TextSpriteNode - \b DONE\b0\par
\par
\par
\par
OK, so spent the evening chopping everything up into a merrily optimistic bunch of pieces.\par
\b NOW: how to address the polymorphic state issue.\b0\par
What we \i want\i0  is some statically typed, almost monadic means of wrapping states.\par
So entering parameter mode means you have changed the type of TActionState to PlayerParameterState.\par
Can always get from that to the outer states in a strongly typed way, that's no problem.\par
\par
Can even see how you could have State<TEvent, TActionState, TParentActionState> or something similar.\par
\par
\b But how does the transition logic work?\par
\b0 You don't know the type of the state that should be passed in!\par
\par
Well, we can live with the dynamic typing internally to the state machine, as long as we don't have to deal with it in any of our state machine (or other!) code.\par
\par
So, fine.  We constrain TActionState to be a class.\par
Then we can do an "as TActionState" in the infrastructure.\par
\par
ENTRANCE AND EXIT STATE TRANSFORMATION FUNCTIONS.\par
So we do really have TActionState, TParentActionState.\par
The funcs are TActionState => TParentActionState (exit conversion)\par
and TParentActionState => TActionState (entry conversion).\par
In the common case where the two are the same, then it's just the ID func.\par
Since they are both : class, we can check the conversions internally and die immediately in the state machine implementation.\par
\par
OK, got the state machine piece done.  But it doesn't build yet.\par
Still, HUGE STEP FORWARDS since managed to solve the scoped state AND scoped scene graph issues in a way that's perfectly statically typed (from state machine implementor's perspective) and perfectly layered with the hierarchical state machine.  VERY GOOD WORK, BRAVO, PIP PIP.\par
\par
OK here let\rquote s see.\par
So to do what Dane wants, I really do need mixdown.\par
But let\rquote s assume that is OK.\par
What is wanted is:\par
HOME mode is the usual palette interface.\par
Pushing A in home mode does what?  Maybe just lets you drag around.\par
Up takes you to Effect Space.  Your side of the screen is mapped to a four-starfish space.  Hold 1 to set where the mike goes; dropping 1 sets the mike to that combo of effects.  Recording starts recording wherever you pull, and effects follow you while you drag around with the trigger.  A lets you pick up and drag existing sounds.\par
Effect Space is a swing-up rectangle that comes up behind the existing loop field  When you leave it, you get mixdown of all loops you moved \f1\endash  and hence effected \endash  while it was up.\par
(If no mixdown then it just works for knob setting.)\par
In any mode, dragging leaves a beautiful comet trail.  Eventually.\par
In the  corners of effect space, you can use the d-pad to scroll through presets.\par
Home takes ypu back out of effect space.\par
Meanwhile, back in palette mode, pushing Down takes you into starfish mode.  That lets you drag all the arms directly.  Can use this to create presets?  Or just go into starfish mode in the corners?  (Is it corners or mid-sides in effect space?)\par
Are we undoable?  Of course we are.  Home, in palette space, lets you undo one level of effect at a time.  A \ldblquote level\rdblquote  is a set of parameters applied before a mixdown.  We save the original track data. \par
\f0 Really need GC once we have undo\'85.\f1\par
What about keyboard space?  In keyboard space, there is no mike hand, no remote hand.  There are regions mapped to keys, and pressing a key takes you into record mode, with the loopie position centered in that region.  There is one region selected at a time, with shift-select for \par
\par
multiples.  Minus mutes all selected regions, plus unmutes, space toggles.  No effect support at all yet.\par
\par
OK so what do we have?\par
Let\rquote s assume we break it down by state.\par
Palette state:\par
\tab Loop position does not affect loop sound\par
\tab Recording new loops uses current mike effect\par
\tab Pushing 1 pops starfish for mike\par
\tab Pushing A pops starfish for selected loops (1 toggles mike)\par
\tab Minus, plus work as expected\par
\tab Touched loopies are updated based on cursor positioning\par
Starfish state:   PARAMETERIZED STATE\par
\tab Entered with some input actions invoked with the modified parameters (and initial too)\par
\tab Starfish on player\rquote s side\par
\tab Setting starfish legs affects [touched loopies and/or mike parameters, when invoked from palette state]\par
\tab Home backs out to the PARENT STATE\par
\f0\tab\par
\b No, we don't need parent states.\b0   We just factor out the logic into the appropriate state class and we treat it as entered and exited.  Kind of hacky, kind of global, but good enough for the time being.\par
\f1\par
\par
\par
OK so effect space?\par
In effect space:\par
\tab Position determines selection just as in palette space.\par
\tab 1 positions mike icon and sets mike parameters.\par
\tab A grabs selected loops (must be direct touch, no area selection \par
\par
in effect space? Does that work?) and immediately starts applying effects.  Dropping leaves them with those parameters.\par
D-pad at effect vertices lets you swap through presets.  NO.  D-pad lets you swap ALL VERTICES AT ONCE.  You get four completely different effect spaces at a touch.  Swapping effect spaces only takes effect once you pick something up.  If it is too jarring, we interpolate???  Or do we converge by averaging?  That\rquote s just an interpolation technique, let\rquote s try it.  And yes it sets all the effect knobs.  HELL YES.\par
Minus and plus still mute and unmute.  (Or toggle???)\par
\par
OK, that really sounds like a whole different state altogether, but with some common logic for selection update.  But it definitely has the Touched Loopies concept.\par
\f0 Maybe you can hold down A to drag a selection box!!!  That would be so sweet\'85 then dragging those loopies would compress them together (enforcing a min distance with repulsion, but a max diameter of the whole group, in cool sproingy fashion).\f1\par
OK.  So it looks like we can still do all this reasonably easily with the existing hacky bag of state.  Maybe at least carve it up a bit.\par
Still have MicrophoneParameters, TouchedLoopies, all the rest of it.\par
But for something like keyboard state, you really want state-specific state.  How?  \par
Well, maybe you do have states be able to access their parents?  No.  You have an extensible state bag mechanism?  Property bags, essentially?  Yeah, I think I like that.\par
So there is the Loop property bag with the loopies and their touched-ness and muted-ness and positions, there is the Microphone property bag with the mike parameters, there is the Keyboard property bag with the current keyboard regions, etc.  Do states declare which bags they get?  Sure they do.  Or nah, it\rquote s enough that they just pull out the bags they need from the Big Bag.\par
\par
OK so:\par
Palette state uses the Loop and Microphone bags.\par
Same with Effect state.\par
Starfish state doesn\rquote t know WHAT bags it uses.\par
Keyboard state uses the Loop and Keyboard bags.\par
\par
If no Kinect is detected it goes right to Keyboard state.\par
If no Wiimotes are detected but there is a Kinect, it goes to Hand Pose state, where a grip action starts recording and a release starts looping and maybe the other hand\rquote s position does something, I dunno.\par
\par
\f0 - build Menu structure, hierarchically - \b DONE\b0\par
- math to generate N-sided polygon with sides of length TextureRadius\par
\tab - solve for equilateral triangle with known point angle and far side length\par
\tab\par
point of triangle is A, bottom corners are B, C\par
N = number of sides\par
R = TextureRadius\par
\par
length(AB) = length(AC)\line angle(B) = angle(C)\par
angle(A) = 2pi / N = D\par
length(BC) = R\par
\par
convert to right trangle with midpoint M halfway between B & C\par
length(BM) = R / 2\par
angle(M) = 90 degrees\par
\par
length(AB) = (1 / sin(D)) * (R / 2) and done!\par
does it work for N = 2?\par
arcsin(180deg) = 0.  so no, doesn't work.  fine, special-case 1 and 2.\par
\par
oops, arcsin wasn't what I thought.  want reciprocal of sin.  what about zero???  uck, \b FIX THAT LOGIC\b0 , no need\par
\par
- MenuItemNode hit radius is slightly bigger than drawn\par
\tab - can drag sloppily from one into next without leaving either\par
- define MenuState\par
\tab - tracks current TextSpriteNodes\par
\tab - handles tracking which one the user is over\par
\tab\par
\par
HOME MENU (held for one beat):\par
- "delete all my sounds" (or maybe just all created by that player....)\par
- "switch players" \par
- "switch hands"\par
- TEST IT\par
- \b DONE\b0\par
\par
STARFISH:\par
- Implement slider (closest slider, etc., including label)\par
\tab - implement rotation mirroring to get this right \par
- Implement all nine sliders, including highlighting from default position out to wherever sslider is\par
\tab  - \b DONE\b0\par
- Connect up to parameter sets via state machine\par
-\tab - \b DONE\b0\par
\par
\par
- TEST IT - \b DONE!!!!!\b0\par
\par
\f1\par
\f0 EFFECT SPACE:\par
- Implement axes (similar to but modified from parameter space)\par
\tab - use the old "pop effect radius up around the sound" idea - \b DONE\b0\par
\tab - advantages: \par
\tab\tab automatically works for little ones\par
\tab\tab finesses the issue of "clicking on an existing sound causes it to immediately be effected"\par
\tab - NO DON'T DO IT!\par
\tab\tab - model should be "when you let go, that's where you are"\par
\tab\tab - avoids weird interpolation shit that makes no sense\par
\tab\tab - nice predictable model\par
\tab\tab - go to starfish if you want to return to normalcy, or "undo" menu item\par
\tab\tab - \b DONE\par
\b0\par
- No mixdown (yet) - \b DONE ;-)\b0\par
\par
So each drag is instead just a parameter morph of the selected parameters in that direction.  Averaging the values between the two axes where you're going?  Sure why not.  \b DONE\b0\par
\par
\par
- TEST IT.  \b GAH, blew 90 minutes on fucking bizarre audio brokenness, and finally got effect space working after 60 minutes.  WOULD HAVE SO MUCH MORE DONE!  WAAAAA ok I'm better now\par
\b0\par
\par
fix pan effect in effect space -- almost working but not centered properly at origin, not going down in the right direction.  But my God the up and down directions are AWESOME - \b DONE!!!\b0\par
\par
- \b BUY REAL SPEAKERS AND AMP - DONE\b0\par
\par
\par
- SUPPORT ARBITRARY RESOLUTIONS\par
\tab - SCALING FACTOR RELATIVE TO 640x480\par
\tab - \b DONE!!!  FINALLY!!!!!!  huuuuuuge improvement\b0\par
\par
- 2 BUTTON TO SWITCH PLAYERS!!!!! - \b DONE!!!\b0\par
\par
- Menu to switch audience view - \b DONE!!!\par
\b0\par
\par
\f1 -\f0  \f1 Truncate to four beats not eight\f0  - \b DONE\b0\f1\par
\f0\par
- fix popup menu text scaling being off-center - \b DONE\b0\par
- fix popup menu text color... wait what's wrong with it? \b NOTHING\b0\par
\par
- DELETE PlayerState.Side :-) - \b DONE\b0\par
\par
STARFISH POLISHING:\par
- unmuting overwrites volume parameter setting, should restore it - \b DONE\par
\b0\par
- sliders should always have upright text - \b DONE\b0\par
- sliders should have label right-justified - \b DONE\b0\par
\par
- Track which tracks are whose, so you really do delete only your own - \b DONE\b0\par
- Or, add separate menu item - \b DONE\b0\par
- Add menu item for switching players - \b DONE\b0\par
\par
- Clamp effect space / param space to edges of screen (so you don't get them offscreen) - \b DONE\b0\par
- Shrink them both slightly - \b DONE\b0\par
\par
- Add mute/unmute in effect space - \b HAH NOT NEEDED IF EFFECT DRAG IS MODELESS!!!\b0\par
\par
\f1 -\f0  \f1 Pad with space immediately, don\rquote t trap in record mode\par
\f0  \tab - \b NO BAD WRONG, LEAVE IT AS IS\b0\par
\par
- Menu to wipe all effects\par
\tab - \b DONE for mike\tab\par
\tab - \b0 add for touched loopies, only when there are any\b\par
\par
\b0 - Specific effect space menu??? \b NO!\b0\par
\tab - "Undo" to reverse last drag?\par
\tab - Hold for a beat to get popup menu in effect space; click to get out?\par
\tab - \b HAH! MOOT!\b0\par
\par
- Set up XPS 12 with Holofunk, see if HDMI works, do we have HDMI extension cable??? - \b DONE!!!\b0\par
\par
- Go to Radio Shack tomorrow, get MORE phono to 1/8" adapters, look for HDMI extension cable and HDMI-to-VGA adapter - \b DONE\b0\par
\par
- convert to uniform [0, 1] graphic space???\par
\tab - advantage: \par
\tab\tab - get rid of all viewport size multiplications except at very end\par
\tab\tab - real "world space", not working in screen space in app code\par
\tab - disadvantages: \par
\tab\tab - more goddamned refactoring\par
\tab\tab - less intuitive coordinates\par
- DECISION: FUCK IT FOR NOW, time to write FEATURES!  but definitely later\par
 \tab - but do try to write agnostic of viewport size, keep it in mind\par
- NO DON'T DO UNIFORM GRAPHIC SPACE\par
\tab - set viewport based on size of Kinect depth stream\par
\tab - scale viewport, preserving aspect ratio, to size of window\par
\tab\tab - not by stretching bitmap, but by scaling all rendering\par
\tab - so the viewport size changes depending on Kinect 1 vs Kinect 2\par
\tab\tab - therefore need one scale factor for textures vs viewport\par
\tab - and the window size can be whatever\par
\tab\tab - therefore need another scale factor for viewport size to window size\par
\tab - \b DONE!!!\b0\par
\par
- where do we apply this viewport-to-window scaling?\par
\tab - need to apply it in rendering\par
\tab - uniform transformation transformation?\par
\tab - actually maybe it IS worth virtualizing the drawing API and putting this under it\par
\tab - rotations are invariant under uniform scaling (hence have to preserve aspect ratio in viewport-to-window)\par
\tab - \b DONE\b0\par
\par
\par
- Pop up text labels on all four sides OF THE HAND CURSOR?  yes YES YES\par
\tab - determined by the PLAYER MODEL effect preset.\par
\tab - \b DONE\b0\par
\par
- How much time to make the damn presets?  Don't even worry about it at first, make them be just individual effects.  \par
\tab - add one preset per D-pad direction\par
\tab - show the presets around your hand as you switch, then fade them out\par
\tab - \b DONE\b0\par
\par
where is current preset?  not in effect space... needs to be in player model.  that's ok\par
\tab - \b DONE\b0\par
\par
\b - \b0 Tune (reduce somewhat) size of pie menu\par
\tab - much easier to hit now that using "closest" algorithm properly\par
\tab - \b DONE\b0\par
\par
- Add pie chart recording thing?\par
\tab - YES, new beat monitor\par
\tab - Hollow quarter circles show quantized duration, filled quarter circles show beats\par
\tab\tab - INCREASE FILL ALPHA UNTIL FULL\par
\tab\tab - nicely get around having to tessellate a rotating circle....\par
\tab - \b DONE!!!\b0\par
\par
- simplify effect space model to be "born dragging" (more similar to popup model)\tab\par
\tab - \b DONE!\b0\par
\par
- redo beatmeter\par
\tab should show squares for entire measures\par
\tab four measures per line max\par
\tab squares should have... what?  dots inside?  yes let's say so\par
\tab 2x2 internal dot grid flashes LT, RT, LB, RB\par
\tab entire hollow square should flare (use thicker overlaid square)\par
\tab - \b DONE\b0\par
\par
- fix the issues around record mode trigger squeezing\par
\tab - \b DONE???\par
\par
\b0 - Add multiple screen areas?\par
\tab - divide into twelve?\par
\tab - mouse over the intersections?\par
\tab - plus button becomes toggle, not unmute?\par
\tab\tab - no, more nuanced: is toggle directly, but when dragged, \par
- \b NO DON'T DO IT\b0\par
\par
\par
\par
\i should mute and unmute be queued for next measure???\par
\i0\tab not tonight they shouldn't....\par
\tab\b NO DON'T DO IT\b0\par
\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9 .... EPIC BREAK, from May 2013 straight through to November 2013.  SIX MUFUKIN MONTHS.  Why?  AP COMPUTER SCIENCE VOLUNTEER TEACHING EDUCATING FREAKING MANIA.  But look!  Here we are!  The class (thanks be to Jared) is calming.  And Finally\par
\par
\b BACK TO DA FONK\par
\par
\b0 DONEDATE 2013/10/29:\par
\par

\pard\i\f0\fs20\lang1033 DUMPING ALL RANDOM D-PAD INTERFACE BRAINSTORMING, NO LONGER MATTERS.\par
\i0\par
- D-pad\par
\tab - lets you switch between whole sets of four presets!!!\par
\tab - basic wet/dry mix???\par
\tab - hold down D-pad to define one particular preset?\par
\tab\tab - how to do it?  with overlaid starfish?\par
\tab\tab - no... can set effect preset FROM starfish OVER TO effect space\par
\par
\par
OK, if we had mixdown then we would have each drag be its own recorded mixdown in realtime so we loop the identical fucking thing.  BUT WE DON'T\par
\par
\par
THEN, THEN THEN THEN, hook in the damn D-pad in effects mode, holding it makes the starfish pop up????\par
\tab - thumbnail starfish version?\par
\tab - Holding it makes the starfish pop up so there's no mistake.\par
\par
GESTURE BRAINSTORMING:\par
- one hand on hip to enter effect mode\par
\tab - grab with either hand to knob-drag\par
\tab - GRAB WITH BOTH HANDS TO TIME-RECORD KNOB-DRAG EFFECT\par
\tab - effect recording timing can be independent of loop timing!!!  TOTALLY INDEPENDENT.\par
\tab\tab - but follows same timing policy.\par
\par
\tab - maybe in effect mode, having one hand on hip allows effect selection.\par
\tab\tab - spread->fist pops up axial effect selection pie menu.\par
\b\par
\b0 - one hand to mouth (or both hands to mouth?) to enter mike mode\par
\tab - then either hand spread->fist starts recording, fist->spread drops loopie\par
\b\par
\b0 - both hands to head to enter "headphone mode" (aka per-player B-channel)\par
\tab - how many goddamn audio outs do I have now?\par
\par
- group selection with L-shaped hands in effect mode?\par
\tab - then effect mode as usual\par
\par
- MENU: maybe one hand behind the back?  hmmm, not very satisfactory.\par
\tab - well then, what about hand pose?  maybe thumbs up?\par
\tab - maybe hand on head for menu.  hmm, that actually could work.\par
\par
- ONE HAND ON TOP OF HEAD: MENU MODE.  other hand spread->fist: pop menu, fist->spread: pick.\par
- BOTH HANDS FROM SIDES TO HEAD: HEADPHONE MODE.  Reverse gesture to exit headphone mode.\par
\par
Ugh, "one hand to mouth" too close to "one hand on top of head"?  And top-of-head too doofy looking?\par
\par
Actually, maybe one hand behind the back for menu is OK.  It means you can't sing into the mic when picking from the menu.  Will have to try it both ways -- or maybe behind-back OR head-top for menu mode, see which one works better.\par
\par
\par
SO: menu mode, mike mode, effect mode.\par
What about mute/unmute?\par
\tab Maybe in mike mode, holding still and spread->fist is mute, fist->spread is unmute.  Then could do two hands for that.  Need to have one hand at mouth to do recording in that scenario.  Will have to try it, it's the only way.\par
\par
No, volume is an effect.  Maybe volume is "default effect" in mike mode.\par
Maybe \i mike effect can be applied to tracks in mike mode.\i0\par
But then how do you switch effects, in mike mode OR effect mode?\par
\tab - one hand on hip.\par
hm, perhaps this "mode" thing is kind of bogus.  think of it as POSE.\par
\par
- effect selection pose: one hand on hip.  other hand: pick axis effects.\par
- default pose (both hands away from body): grab to apply effects, let go to release.  Two-hand grab to record an effect, let go to stop recording.\par
- menu pose: one hand behind back.  other hand: pop up and pick from radial pie menu.\par
- record pose: one hand at mouth.  other hand: grab to start recording, let go to loop.\par
- headphone pose: both hands on head.  enter mode in which newly recorded sounds are audible only to performer, until headphone pose exited (via assuming the pose again).\par
\par
RIGHT, IT'S NOT ABOUT MODES, IT'S ABOUT POSES.  \i POSES ARE MODES OF THE BODY.\i0\par
\par
FUCK yes, this is the quality shit RIGHT HERE.\par
\par
\b CATCH UP WITH 2013:\par
\par
\b0 - install VS2013 - \b DONE\par
\b0 - test build with VS2013 - \b DONE\par
\b0\par
\par
- update to newest SharpDX\par
\tab - try source first... install DirectX - \b DONE\par
\tab\b0 - ghaa, still not picking up DXSDK_DIR\par
\tab - no wait, yes it is.  rebuilt all as DIRECTX11_2 but let's get new KSDK up first.\par
\par
- rip out all the Wiimote business - \b DONE\b0\par
\par
- Kinect for Windows \b 2.0 SDK WOOOOOOOOOO\par

\pard\sa200\sl276\slmult1\b0\f7\fs22\lang9\par
\par
DONEDATE 2013/12/27:\par

\pard\f0\fs20\lang1033 Oh for fuck's sake, can I really get something working by March 15th?!?!?!\par
\par
actually has to be a lot sooner than that.\par
But how much do I need to have working?  Minimum: hand pose, video looping.\par
How feasible will video looping actually be? \par
\par
CRITICAL ITEMS:\par
- body pose recognizer\par
- per-hand state machines\par
- green-screen texture capturing and looping\par
\par
If I can't get the first two done in January, I suck.\par
And if I can't get the second one done in February, I suck worse.\par
\par
But still, is March 15th too soon to show something???\par
Thing is, it's the only option if I want to show it this year....\par
\par
...means I'd need to frontload the purchase of the wireless headset and the wireless headphones...\par
...and I still don't know where to get the wireless headphones.....\par
\par
\par
Well, anyway, the A #1 jobs are the body pose recognizer and the per-hand state machines.\par
Also need a hand pose recognizer which just slightly smooths the hand pose state stream and translates into transition events.\par
And need to figure out how to modify the state machine mechanism to support prioritized, guarded transitions.\par
\par
AND need to figure out how to avoid state machine action duplication when doing just one action per hand.\par
\par
AND AND need to know whether the whole concept will work, which will add a good 2x on the total time required....\par
\par
AND need to keep up with lesson planning for fucking AP class.....\par
\par
......crap, this is all adding up to "not enough time before March 15th."  If I had only gotten on the stick last year with the video capture, it would be a lot better.  But this other ambidextrous business really couldn't have been done last year, so needn't feel too bad about that.\par
\par
\par
Well anyway, forget the yes/no question of "do I have enough time?"  Can always just step the fuck back from the class.  DO NOT GRADE ANY OF THE FRACCALC SHIT, LEAVE THAT UP TO JARED. That will help.\par
\par
And take ONE STINKIN' MENTAL HEALTH DAY this week to focus on the hand/body pose recognizers.  If can get that stuff working by the application deadline for maker faire, then it will be a go.\par
\par
OK fine that works.\par
\par
So.  Let's get to it!\par
\i REMEMBER TO CHECK OUT EVERYTHING FOR EDIT AS SOON AS BACK ONLINE WITH HOME P4S\i0\par
\par
Design question: how to handle full-body interactions (e.g. both arms outstretched)?\par
Let's brainstorm this because it really affects the details of the state machine.\par
\par
Perhaps the simplest way to think of it is that one hand knows what the other hand is doing.\par
Both hands are in the SAME STATE.\par
If both hands are in the same state, then -- aha!  What SHOULD the volume be if each hand does something different???  Let's just say it's the average of the two hands.\par
The "action handler" for each hand could even just redundantly apply the average volume of each hand separately.\par
In other words, just let them do the same action, as long as the action is idempotent.\par
OK, that'll do for the moment.\par
\par
- CHECK WHAT BODY TRACKING SAMPLE DOES WHEN YOU'RE HOLDING A MIKE\par
\tab - it mostly doesn't recognize your hand!  YAY!  maybe some overall % recognition measure that gets converted to assume mike if only one hand fits it....????\par
\par
\par
OK OK OK.\par
bassasio livefx sample working.\par
\par
- scarlett mixcontrol says something is running so it can't change the sample rate.  what is running???\par
\tab - manually killed "HD audio background application" or something\par
\tab - closed sound control panel\par
\tab - then it worked, and DIDN'T crash\par
\par
- clicking "m" on the "anlg input 1" channel in MixControl shows a level on the mike, but nothing on the mixer... and the BASS livefx bassasio test app doesn't hear anything either!  Is the bassasio listening to mixcontrol output???\par
\par
- and now livefx stopped working, wtf?  was it the "HD audio background application"?\par
\par
- and now can't reset sample rate again because of "audiodg.exe"???????  WTF IS THAT\par
\tab - killed "holofunky" process?????  was that running the whole time?\par
- also "realtek audio service" and "realtek HD audio manager" -- left them alone\par
- BUT STILL SAYS AUDIODG.EXE IS RUNNING\par
\tab - .....had to restart\par
\tab\par
THEN could set to 48Khz.\par
What does livefx do now???????  \b FUCKING NOTHING, AGAIN.\b0\par
\par
Why the fuck did livefx work once and then not at all????????\par
\par
And now it says audiodg.exe is running again.  Will this mean a restart every fucking time??!?!??!\par
shit, should try m-audio again soon\par
\par
relaunch mixcontrol, it resets to 44.1Khz?????  wtf is that?  Or is it livefx that does that?  \par
\tab - and then I can reset it in mixcontrol, no more audiodg.exe complaint despite not killing anything\par
\tab - and then it sticks in mixcontrol.  so it is livefx that does it.\par
\par
\b BUT THEN, "RESET TO FACTORY DEFAULTS" GETS LIVEFX WORKING AGAIN.\par
with horrid 22ms latency.  what can be done???\par
- kill livefx, set mixcontrol latency to 1.0ms, run livefx, says it is 7.8msec and maybe livable.\par
- OK phew, so we have some kind of semi-sanity.\b0\par
\par
So what BROKE livefx previously?  Fuck it, let's just try it with Kinect.\par
PLUG IN KINECT WHILE LIVEFX RUNNING - no problem\par
LAUNCH KINECTSERVICE WHILE LIVEFX RUNNING - NO PROBLEM!!!!\par
\par
this is a very good thing.\par
Sooooo, let's try bass.net sample???\par
The BASS.NET SimpleAsio sample still won't record through \par
\par
\par
\par
By putting the x86 bass.dll (version 2.4.10) and the x86 bassasio.dll (version 1.3.0.2) into the bassasio\\c\\bin folder, I could run list.exe, and it produces a perfectly nice list of all the input and output channels, just as my code above does.\par
\par
I am able to run the livefx bassasio sample using the x86 versions of those .dlls, and I can hear the reverb effect clearly.  So there is obviously hope :-)\par
\par
However, the BASS.Net SimpleAsio sample is not as happy. I have VS2012 and I have to convert the Samples.sln to load it.\par
\par
With the x64 version of bass.dll 2.4.10, and the x64 version of bassasio.dll 1.3.0.2, the SimpleAsio sample is able to play, but it refuses to record; it puts up a dialog saying "Asio Device could not be started!"  These two lines of code are failing:\par
\par
\cf7\highlight8\f8\fs19 [code]\f4 _asioIn = \cf1 new\cf7  \cf2 BassAsioHandler\cf7 (\cf1 true\cf7 , comboBoxAsioInputDevice.SelectedIndex, comboBoxAsioInputChannel.SelectedIndex * 2, 2, \cf2 BASSASIOFormat\cf7 .BASS_ASIO_FORMAT_FLOAT, 48000d);\par
\cf1 if\cf7  (_asioIn.Start((\cf1 int\cf7 )\cf1 this\cf7 .numericUpDownAsioBuffer.Value, 0)) \{\f8 [/code]\par
\f4\par
\cf0\highlight0\f0\fs20 (Note that the sample actually didn't compile for me against BASS.Net 2.4.10.3 until I added the second 0 argument to _asioIn.Start.  I think the 2.4.10.3 samples may need some updating?)  \par
\par
This fails with buffer values of 0 or 128.  \par
  \par
If I replace the x64 bass.dll and bassasio.dll with the x86 version, then whammo, BadImageFormatException:\par
\par
\tab   at Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfoInternal(Int32 A_0, a& A_1)\par
\par
Expected, I suppose. I put the x64 DLLs back, and get back the prior behavior -- recording doesn't work.  \par
\par
So it seems to be something specific to BASS.NET in this x64 context.\par
\par
I tried the AsioRecording sample, and found it needed the x64 bass.dll and bassasio.dll to start up.  Then I found it needed bassenc.dll, but when I dropped in the only available version of bassenc.dll in the 2.4.9.1 zip file, I got a BadImageFormatException on this line:\par
\par
\cf7\highlight8\f8\fs19 [code]\f4                 wav.Start(\cf1 null\cf7 , \cf2 IntPtr\cf7 .Zero, \cf1 false\cf7 );\f8 [/code]\f4\par
\cf0\highlight0\f0\fs20\par
Does the 2.4.9.1 bassenc.dll (presumably x86) load properly into a BASS.NET application that is using the x64 versions of bass.dll and bassasio.dll?\par
\par
In general, am I getting anything wrong with respect to x64 usage of BASS.NET?  How can I further debug why SimpleAsio is failing to Start?\par
\par
System.NullReferenceException was unhandled\par
  Message=Object reference not set to an instance of an object.\par
  Source=Bass.Net\par
  StackTrace:\par
       at Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(Boolean input, Int32 channel, IntPtr buffer, Int32 length, IntPtr user)\par
  InnerException: \par
\par
\par
....but overall, IT STARTED WORKING?!?!?!?!?!?!?\par
\par
\i why exactly did it just start working. how reliable is this setup going to be\ul\i0\par
\par
but aaaaanyway, let's actually try Holofunk for shits and giggles\ulnone\par
\par
\par
\par
RESTART "POST":\par
\par
I was able to get the setup working with BASS 2.4.10, BASSAsio 1.3.0.2, and BASS.NET 2.4.10.3.  The BASSAsio list and livefx samples both worked (with the x86 DLLs), and after some fiddling the BASS.NET SimpleAsio sample started working -- it had some issues with recording initially, but those somehow resolved.\par
\par
A couple of things I noticed:\par
\par
- I had to edit the SimpleAsio and AsioRecording BASS.NET samples before they would compile; the sample code was written with a single argument to BassAsioHandler.Start, but the 2.4.10.3 API changed to make that method take *two* arguments.  Do the samples need updating?\par
\par
- I am on a 64-bit OS (as mentioned earlier in the thread), and I can't get the AsioRecording BASS.NET sample to work; it initializes BASS and BASSAsio with the x64 versions of those DLLs, but when I put the 2.4.9.1 bassenc.dll in the directory, it throws BadImageFormatException as soon as it tries to write a .wav file.  Is this expected?  What is bassenc.dll's x64 story?  bassvst.dll, bassmix.dll, bassfx.dll all have 64-bit versions, but not bassenc.dll AFAICT....\par
\par
\ul\b\i BUT NOW HOLOFUNK INITIALIZES PROPERLY\ulnone\b0\i0\par
\par
woooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\par
\par
OK so let's shut down and try again from clean restart ----  YESSSSSSSSSSSS\par
\par
\par
holy shit.  I just tried running it again and got the BASS_ERROR_UNKNOWN from BASSAsio_Start, BUT, I then killed the *two* "HD audio background application"s and THEN IT INITIALIZED ASIO SUCCESSFULLY.\par
\par
w\par
t\par
f\par
\par
BUT now is working again.  AND got strobing rainbowy thing!  Looks like maaaaay just have some progress here.........\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
DONEDATE 2014/01/31:\par

\pard\f0\fs20\lang1033 - implement ASIO callback on C++ side\par
- get it working\par
\par
horrible horrible flailing with scarlett and cursed BASS_ERROR_UNKNOWN.\par
finally doubled buffer size and suddenly working again.\par
now let's fuck it right back up by trying to get vst's & etc.\par
first bassfx init:  well, that worked.\par
then bassvst init:  BASS_ERROR_UNKNOWN startup whammy.\par
Wait, is it? Yep.\par
Take it back out, and what?  \b GOD FUCKING DAMN IT.  STILL BASS_ERROR_UNKNOWN.\b0\par
\par
What is this SHIT where it gets into some unfeasible state just from trying ONCE to load the damn VST library?\par
AND EVEN SURVIVING REBOOTS?\par
\par
Let's see if have to power down Scarlett AND restart the XPS12 to get back to working state.  Here goes.\par
\par
Well, it worked BRIEFLY. Then stopped working again, not clear why, think I just commented out some code and moved the VSTs out of the way, is all.\par
\par
Where the fuck was Turnado ever loaded? Ambiguously in the AllEffects constructor.  Jeez, that shit is a bit convoluted.\par
\par
AAAAAH, MORE WEIRDNESS: LAUNCHED IT AND NO ANIMATION, ASIO SAMPLES NOT FLOWING.\par
Flail around, then just quit and relaunch it, AND THEN WORKING.\par
\par
\par
Do I even know for sure I have turnado x64?\par
\par
Serial: 73953709\par
\par
VST 64bit Plugin Directory:\par
      C:\\Program Files\\Common Files\\Steinberg\\VST2\par
\par
Destination location:\par
      C:\\Program Files\\Sugar Bytes\\Turnado\par
\par
Preset Directory:\par
      C:\\Users\\rjelling\\Documents\\Sugar Bytes\\Turnado\\\par
\par
WOOOOOOOOOOOEEEE  I HAVE WEIRD BROKEN SHIT ON SCREEEEEEEEEEEEEN\par
\par
and that will DO NICELY FOR TONIGHT SIRS\line\par
\par
(and why do I always hear mike monitor even when no asio app running?  :-P  )\par
\par
\b MILESTONE: HAND TRACKING WITH JUST RECORD/LOOP\par
\b0 no support for effects or menus whatsoever.  Get that working minimally.\par
\par
\par
Remove all the hacky hardcoded two-player stuff; two players is a special case of N players.\par
\par
- hand pose "averager" (x2 per player) - \b DONE\b0\par
- revised per-hand state machine (x2 per player) - \b DONE\b0\par
\par
Figure out how to handle more players than hand tracking can support.\par
\par
WHAT IS THE NATURE OF THE BODY-TO-PLAYERMODEL MAPPING?\par
That is what is missing right now.\par
How did that work BEFORE?\par
Go back and figure that out....\par
\par
...but not tonight.  toooo sleeeeepy.\par
\b DONE\par
\par
\par
\b0 TEST THE DAMN THING!\par
- updated SharpDX, got that working, \b DONE\b0\par
- updated BASS, got that loading, \b DONE\b0\par
\b\par
\b0 Does Turnado need the x64 version?  IS there even one?\par
yes there is and yes it does but crashing with dsp / fx.  hacked it right out.\par
\par
WHY FAILING WITH DSP/FX?\par
WHAT IS MINIMAL FAILURE?\par
\par
Then, test failed because Rectangle went to xywh rather than xyxy.  How many other places will this bite us?\par

\pard\sa200\sl276\slmult1\par

\pard\b MILESTONE: CLEAN UP HAND ASSUMPTIONS\par
\par
\b0 need to fix up concept of "wii hand" and "mike hand" -- those no longer exist -- RIP CONCEPTS OUT\par
\tab - DONE\par
\par
- clean up conceptual lingering weirdness with ambidexterity:\par
\par
\tab - what if you have same effects on both hands simultaneously?  are they averaged or what?\par
\tab - is that even currently possible?\par
\tab - let's say it IS possible and moreover it is what is done.\par
\tab\tab - need one "proposed parameter set" per hand and a function to combine.\par
\par
- get out of record mode by POINTING and then closing.  that's how to get back to inactive.\par
\tab - to get into effect / mute mode you have to OPEN again and THEN point.\par
\tab - or you can just open again, or go to unknown.\par
\par
- animating parameters by closing and holding: how do the time envelopes work?\par
\tab - two simultaneous recordings of animated effects with the same parameters?\par
\tab\tab - with both hands: open, point, close, wave same parameters around\par
\tab\tab\tab - but distinct time intervals.\par
\tab\tab\tab - what is the resulting effect?  multiple recorded envelopes always mixed when replayed?\par
\par
- and what if you record EVEN MORE animated parameters of the SAME EFFECTS over the top of the current ones?\par
\tab - mix-down \par
\tab - actually mix-down is the only way when animating anything at all, because you can't get exactly the same sound twice, and you don't want chaotic effects to sound different when looped!\par
\tab - So: effects are averaged between the hands, and the result is recorded live into another push stream.\par
\tab\tab - Once looping begins, the original stream is no longer the source for that track.\par
\tab - This supports undo.\par
\par
\par
WHAT ABOUT MICROPHONE EFFECTS?  How exactly are they done again?\par
\tab - hold one hand to mouth?  no, don't like it.\par
\tab - point in front of mouth?  hmm, doesn't seem too great.\par
\tab - point BESIDE mouth?  yes, let's say that's it.\par
\par
\tab - maybe effect selection affects the mike by default???\par
\tab\tab - but still need a way to affect the mike effect!\par
\par
maybe mike position really is the most natural after all.  Because if you really do have a mike, it will be what you want to do anyway.  OK fine, let's say that's what it is.\par
\tab - So you put an effect on your hand as usual, then you move the other hand to mike position and you effect-mode the mike parameters.\par
\tab - Animating the mike parameters can be done the same way.\par
\tab - But animated mike parameters don't cause mixdown! They just keep waggling.\par
\tab\tab - Maybe that should be true for tracks also.... hmmm.... tricky tweening issues.\par
\tab\tab - OR NOT, given robust sampling.\par
\tab\tab - Perhaps there is an AveragingStream!!!  that can tween arbitrary envelopes!\par
\par
NO NO NO NO NO.\par
Plan of record is:  NO ANIMATED EFFECTS.  Fist during effect is actually RECORD NEW TRACK FOR EACH TRACK THAT REPLACES SELECTED TRACK. "Undoable overdub", in other words. Uses more memory but so what?\par
\par
HOW GOOD IS DX11 TEXTURE COMPRESSION?\par
CAN IT BE INVOKED AS A SIMPLE LIBRARY?\par
DO WE REALLY WANT TO KEEP ALL THE TEXTURES ON THE GPU?\par
WHAT IS BEST VIDEO TEXTURE STREAMING IMPLEMENTATION ON THE GPU ANYWAY?\par
WHEN DO WE NEED TO START TIMING THIS?\par
DOES HOOK'S PROFILER HELP WITH TIMING SHARPDX APPS?\par
\par
No animated effects avoids a whole shitload of issues, especially the need to work out interpolated tweening of effect envelopes. All we need is ParameterMaps just as they are.\par
\par
\par
- implement unsynchronized ring buffer communication layer\par
\par
(Worst comes to worst, write to xoofx directly.)\tab\par
\par
Turnado version 1.5.0.0, (c) 2011.  Hmmmm.  Any updates??? ...nnnope :-(\par
\par
{{\field{\*\fldinst{HYPERLINK http://www.un4seen.com/forum/?topic=15406.0 }}{\fldrslt{http://www.un4seen.com/forum/?topic=15406.0\ul0\cf0}}}}\f0\fs20  -- new bassasio.dll version,but don't think it affects my problem.\par
\par
x64 ASIO driver issue?  could be, could be....\b\par
\par
MILESTONE: SUPPORT FOR EFFECTS BUT NO MENUS.\par
\par
\b0 Meanwhile what about state machines?\par
\par
- Other-hand akimbo: special event type.  Maybe can flag "this hand", "other hand" events!\par
\tab - Yes, I like that.\par
- Other-hand akimbo does "event transition" whenever entering "armed" state.\par
\tab In other words, whenever "armed" state is entered, if the current other-hand pose is akimbo, the system\par
\tab acts just as if an other-hand akimbo event had occurred in armed state.\par
\tab Doesn't matter whether you arm then akimbo, or akimbo then arm.\par
\par
- So may need some concept of "state trigger actions" (distinct from state entry actions).\par
\par
- Meanwhile, for mute/etc., these should be individual states.\par
\tab - The transition behavior is determined by the current model!\par
\tab - Specifically, the transition has, not a state, but a Func<TModel, TState> that computes the state given the model!\par
\tab - This lets us have unconditional transitions with COMPUTED TARGETS.\par
\par
So, core event features needed:\par
\par
- this-hand, other-hand event flags\par
\par
- "trigger action" on a state, invoked whenever the state becomes active (even if not being entered from outside)\par
\tab - this then gets used to ensure we enter popup menu state if we go other-hand akimbo while still\par
\tab\tab actively gesturing with this hand\par
\par
-  computed transition; allows model to save current interaction mode and map it to state\par
\tab - used for switching the pointing interaction (mute/unmute vs. sound-effect-setting)\par
\tab - mute/unmute\par
\tab - effects [0 through N]\par
\par
Then implement akimbo detection, and whammo, you've got all the pieces to wire up akimbo popup menu allowing switching between mute/unmute mode, and effects modes 0 through N.\par
\par
\par
After sleeping on it:  NO NO NO!  MUCH SIMPLER!  All you need are computed transitions!\par
\par
Computed transition from Armed on Pointing first checks pose of other hand -- if it is Akimbo, then transition jumps to HandModeMenu state!!!!!  Exactly and only the place that cares.  No need for "trigger actions" or "other-hand events" -- you don't change \i state \i0 on akimbo, you change \i transition destination\i0 .  This then trivially works for SystemMenu state (hand pose BehindBack).\par
\par
GOD, IT'S SO BEAUTIFUL. \par
\par
- implement computed transitions - \b DONE!\b0\par
\par
- implement parentwards transition search - \b DONE!\par
\par
\b0 - rearrange state machine to go into MutePointing sub-state conditionally.- \b DONE!\b0\par
\par
- implement HandMode enumeration:\par
\tab MuteUnmute\par
\tab Effect\par
- re-enable ParameterMap, per-hand this time\par
\tab - needs to go in the PlayerHandModel\par
\tab - as does the HandMode\par
\tab\b DONE!\b0\par
- build in computed transition to either PointingMuteUnmute state or PointingEffect state \b DONE!\b0\par
\par
- re-define the PointingEffect state and its dependents, YES!!!!! \b DONE!\b0\par
\b\par
\par
\par
\b0 - extend per-hand state machine for effect state, pointing \b DONE!\b0\par
\par
\par
\b MILESTONE: AKIMBO POSE RECOGNITION, EFFECTS MENU SUPPORT\b0\par
\par
- arm pose recognizer, akimbo only - \b DONE!\par
\par
\b0 - implement elbow labels for arm pose debugging (left-justified vs. right) \b DONE!\par
\b0\par
\b MILESTONE: BEHIND-BACK POSE RECOGNITION, MAIN MENU SUPPORT\par
\b0\par
- extend arm pose recognizer for BehindBack\par
- wire up main-menu state\par
\tab\b DONE!\par
\par
\b0 fractional BPM issue: how real is it?\par
\tab - for a one-beat loop at 120 bpm, that's 1/2 a second.\par
\tab - let's say it's 121 bpm.  48Khz / 121 = 396.6942 samples.\par
\tab .6942 / 396 * 48000 = 84.14545 samples per second clock drift.DenseStr\par
\tab 5048 sample drift per minute, and that's about 1/9th of a second at this point, easily noticeable.\par
\par
So clock drift is a real thing.  What to do about it?\par
\par
- Calculate the current fractional beat as is done today.\par
- The duration of a loop must be measured \i fractionally\i0 .\par
\tab - You can't have an enum synonym for duration, but you can have implicit operators.\par
\tab - Duration has to be a floating point number in audio time!\par
\tab\par
So perhaps AudioTime SHOULD be floating point.\par
\tab No, let's have BeatTime and SampleTime.\par
\tab BeatTime is also measured in samples, but is fractional.\par
\tab SampleTime is an int-based enum.\par
\par
Need to be super careful about knowing how many samples to copy at the end!  And need to not drop the fractional beats when rolling it over.  How does one avoid that???\par
\tab -> when slicing forwards, one finds when one's reached the end of the buffer, the point at which the beat count increments.  And that will vary naturally within a single sample's range about the rounding point.  So always need to round up when calculating the total sample length.\par
\par
And a DenseStream<TTime, TValue> always has a way to look it up as of a BeatTime.\par
\par
So: a SparseStream<SampleTime, byte> with ChunkSize=[2D texture size] wraps an underlying List<SampleTime> and an underlying DenseStream<FrameTime, byte> with the same ChunkSize.  FrameTime is pure integer as is SampleTime. Index in List<SampleTime> points straight to the right Frame.\par
\par
How exactly does it point?  It gives the frame count, from which the DenseStream can be point-sampled.  But wait, it's not really a simple DenseStream, is it?  \par
\par
Stream<TTime, TValue>\par
\tab BeatTime Duration\par
\par
DenseStream<TTime, TValue>\par
\tab BeatTime Duration // possibly fractional based on BPM at time of recording\par
\tab List<DenseSlice<TValue>> Slices // the actual data sliced out of underlying Buffers\par
\tab\tab // once the stream is closed, Slices.Sum(slice => slice.ValueCount) == Math.Ceiling(Duration)\par
\tab\tab // -- in other words, the stream always has enough samples if the rounding goes upwards\par
\tab bool TryGetNextSliceAt(TTime startTime, TTime endTimeInclusive, out DenseSlice<TValue> slice)\par
\par
\tab // copy from this stream into the target slice, respecting chunk size\par
\tab void CopyInto(TTime startTime, TTime endTime, DenseSlice<TValue> target);\par
\par
SparseStream<TTime, TValue>\par
\tab List<TTime> times // index into dataStream\par
\tab int ChunkSize // number of TValues per TTime\par
\tab DenseStream<IndexTime, TValue> dataStream // dataStream.ChunkSize == this.ChunkSIz\par
\tab\par
\par
Yep, I love it.  So we can represent the audio stream with DenseStream<SampleTime, StereoSample> with ChunkSize 1 (only one StereoSample per SampleTime).  Or we could just do DenseStream<SampleTime, float> with ChunkSize 2!  Hmm, let's go with that!\par
\par
Then we represent the video data with DenseStream<IndexTime, byte> with ChunkSize = 100 x 100 x 4 (very conservatively given our horrid resolution) = 40,000 bytes, or, rounding up, 40Kb.  40Kb x 30 fps (again, looking ahead) = 1.2Mb.  1.2Mb x one hour (3,600 seconds) = 4,320Mb.  WHOOPSIE!\par
\par
But 60 minutes would be 60 one-minute loops.  At 60 bpm, a one-minute loop is 60 beats long, or 15 measures at 4/4 time.  That's CRAZY LONG.\par
\par
So conservatively we can say 2Gb of RAM dedicated to video looping will be enough for 60 concurrent 30-second loops (7.5 measures at 60 bpm, 4/4 time).  THAT SHOULD BE PLENTY EVEN WITH TWO PEOPLE.\par
\par
Moreover, 1.2Mb per second says that we want 1Mb buffer granularity.\par
\par
AND,we can easily snarf up 4GB of RAM just for video texturing on the 8GB tinkybox!\par
\par
From airplane design notes:\par
\par
\par
class DenseChunkPool<T>\par
\{\par
\tab Queue<T[]> m_freeChunks;\par
\tab // only populated by allocated chunks\par
\tab Map<T[], int> m_chunkRefCounts;\par
\par
\tab // return a whole-chunk slice\par
\tab DenseSlice<T> AllocateChunkSlice();\par
\par
\tab // decrement ref count and free if zero.\par
\tab // when do we actually call this?  when stream is deleted.\par
\tab // can iterate over all T[]'s held by that stream.\par
\tab // streams can never share chunk slices.\par
\tab void Free(T[] chunk);\par
\}\par
\par
readonly struct DenseSlice<T>\par
\{\par
\tab T[] m_storage;\par
\tab ChunkOffset m_start;\par
\tab ChunkSize m_size;\par
\par
\tab // chop some off the front of this slice\par
\tab DenseSlice<T> After(ChunkSize size);\par
\}\par
\par
// hmm, how does sparse slice of texture(s) work?\par
// can't split value data across chunks; only one DenseSlice per SparseSlice\par
struct SparseSlice<T>\par
\{\par
\tab RelativeTime m_startingTime;\par
\tab DenseSlice<T> m_value;\par
\}\par
\par
class DenseBufferedStream<T> : IDisposable\par
\{\par
\tab DenseChunkPool<T> m_pool;\par
\tab ArrayList<DenseSlice<T>> m_data;\par
\tab AbsoluteTime m_startTime;\par
\tab Duration m_totalDataDuration;\par
\tab DenseSlice<T> m_currentChunkRemaining;\par
\par
\tab TimeMapper m_mapper;\par
\par
\tab // if this is Duration.Undefined, then it's unbounded; otherwise this will be the duration that gets buffered\par
\tab Duration m_maxLength; \par
\par
\tab public void Append(DenseSlice<T> sliceToCopyFrom);\par
\par
\tab public DenseSlice<T> NextSliceAt(AbsoluteTime absoluteTime, Duration duration);\par
\par
\tab public void CopyTo(AbsoluteTime absoluteTime, DenseSlice<T> target);\par
\}\par
\par
DenseBufferedStream<StereoSample> is the backing store for a track.\par
\par
\par
class SparseBufferedStream<T> : IDisposable\par
\{\par
\tab DenseChunkPool<T> m_pool;\par
\tab ArrayList<SparseSlice<T>> m_data;\par
\tab ChunkSize m_dataSliceSize;\par
\tab AbsoluteTIme m_startTime;\par
\tab Duration m_totalDataDuration;\par
\tab DenseSlice<T> m_currentChunkRemaining;\par
\par
\tab public void Append(AbsoluteTime currentTime, DenseSlice<T> data);\par
\par
\tab public SparseSlice<T> Sample(AbsoluteTime startTime, Duration intervalLength);\par
\}\par
\par
\par
SparseBufferedStream<byte> is the type for capturing textures, with dataSliceSize set to 100 x 100 x 4 = 40,000 bytes exactly.   OK, I really like that!!!\par
\par
And then, and then, DenseTimeMappingStream<T> and SparseTimeMappingStream<T> can do time remapping operations orthogonally!  LOVE IT LOVE IT.\par
\par
\par
\par
Then the Loopie has a DenseBufferedStream<StereoSample> and a SparseBufferedStream<byte>.\par
FloatTrack gets replaced with StereoFloatDenseBufferedStream.\par
\par
\par
Yep, I love it!\par
\par
\par
\par
Should AbsoluteTime and Duration be FLOAT-based??????\par
- why?  because would lead to much greater precision for arbitrary BPM.\par
\tab - probably would eliminate clock skew at any tempo, for all practical purposes.\par
\par
- But RelativeTime should be discrete?\par
\tab - How do we handle quantizing of the float time?\par
\par
- AbsoluteTime should be exact: number of samples since launch.  "now" is always an AbsoluteTime.\par
- Duration is float: it can be a NON-EXACT number of samples.\par
- Can always quantize an AbsoluteTime + a duration... but what do you get?  Don't want to lose the fractional part!!!\par
\par
- So AbsoluteTime IS a float, but its UNITS are SAMPLES.\par
\tab - Quantizing is done by converting an AbsoluteTime into a RelativeTime (always exact), using rounding.\par
\par
....No, not quite. Should RelativeTime be fractional too?  So can have multi-beat loop that has a non-integer duration?  And how do you even play such a thing?  You need to divide by the fractional duration when converting an AbsoluteTime into a RelativeTime... and that then Just Works.\par
\par
OK, so RelativeTime is number of samples since start of [context], and AbsoluteTime is number of samples since start of Holofunk.  And really it is ONLY durations that are floats!  WHOA, INTERESTING, I LOVE IT!!!\par
- Branch holofunk_stable off of holofunk.- DONE\par
\par
- FIX POPUP MENU BUGS.  - DONE\par
\par
\par
\par
OK almost over the hump on BufferedStream.  - DONE\par
\par
\par
Where exactly does Holofunk.Update get called from, and on what thread?\par
\tab - Label threads for easier debugging?\par
\tab - Thread assertions?  could just use name....\par
\tab - Where exactly should video splicing get hooked in, and on what thread?\par
\tab\tab - Can we be sure of no racing between the Kinect repainting the texture, and the\par
\tab\tab\tab video recording copying out of the buffer?\par
\tab\tab - Yes, if we just lock the texture itself before getting it or setting it.\par
\par
Should probably have something on the Kinect thread, because you don't want to copy any video data that's stale.\par
- If you have something on the Kinect thread, then what is it???\par
\tab - List of TextureCopiers.\par
\tab\tab - TextureCopier: defined in Holofunkinect.\par
\tab\tab\tab - argh, will need a way to copy with stride, or else a way to allocate a new slice before populating it.  Slices have no stride right now so it doesn't just fall out.  Feh.\par
\par
BUT GOOD NEWS IS, define a TextureCopier that has a SparseSampleByteStream target, get the minimal-copying right, lock the SparseSampleByteStream when appending to it or getting a slice from it (or shutting it), and we could be very good.  Will need to add the video Stream into the Loopie.  WIll need to be able to get back to that stream to find the texture later.\par
\par
SEEMS TOTALLY DOABLE IN ONE NIGHT, CODING-WISE.\par
\par
\par
\par
\par
- Ensure ready for class on Wednesday.\par
\par
\par
\tab\par
Still to do on streaming though:\par
- duration cap, with trimming / freeing once cap is reached\par
- stream freeing / refcounting\par
- EPIC TEST SUITE including lots of roundoff testing, LOTS\par
\par
THEN:\par
- SparseStream<TTime> -- shouldn't be too tough....\par
\par
\par
\par
FFFFFFFFFFFFFFFFFFFFUUUUUUUUUUUUUUUUUUUUUUU\par
\par
fucking scarlett ASIO audio seems flaky on the NUC.\par
prone to freezing and no longer delivering ASIO samples randomly!!!!!!!!!!!!\par
\par
FUCKING SUCKS.\par
and this is with mixcontrol 1.8 and evidently the latest Scarlett drivers.\par
\par
Soooooooooooooooo, fuck me.\par
\line\par
NEXT, DRIVE HARDWARE TO STABILITY:\par
- Need to upgrade the Intel NUC BIOS\par
- Need to upgrade all NUC drivers (via excellent NUC site)\par
\par
Then keep testing it........\par
\par
OK, upgraded BIOS and video drivers.  And Win8.1 updates.  And still sometimes flaking.\par
\line BUT, seems very stable except when actively using it.\par
AND, was able to drive it to repro the BUGBUG on lin e299 of Track.cs just by spamming shitloads of tracks with both hands.\par
\par
Overall we want Recorder<Sample, float> on the audio side and Recorder<Sample, byte> on the video side.  Know what the audio side looks like:  pass a per-channel Recorder in to HolofunkBass, and then just control the Recorder implementation.  When track end is reached, update the Recorder state to stop recording that one, and make the whole track start playing.  When user releases the track, keep recording it but don't update its position at all.\par
\par
So what EXACTLY happens when?\par
RECORDING STARTS:\par
- New Loopie is created, with new streams: DenseBufferedStereoFloatStream for audio, and SparseSampleByteStream for video.\par
\tab - Loopie already has the video stream, but not currently the audio stream.\par
\tab - Loopie can be in Recording state.\par
\tab - As long as it is Recording, it exposes two Record methods that append to the stream.\par
\tab - Can it implement Recorder<Sample, float> AND Recorder<Sample, byte>?  kind of bogus....\par
\tab - Anyway, there is also a MultiplexRecorder object that exposes both flavors of Recorder interface.\par
\tab - We have Recorder<TTime, TValue>, and we also have TimedRecorder<TTime, TValue> which passes in a Time<TTime> as well.\par
\tab - DualRecorder<TTime, TValue1, TValue2> : Recorder<TTime, TValue1>, TimedRecorder<TTime, TValue2>\par
\par
MultiplexRecorder<TTime, TValue1, TValue2>\par
\tab - could just have TValue and have it be a tuple type, but not really good, would need to be partial record\par
\tab - yes, really do want this\par
\tab - exposes Add(DualRecorder), Remove(DualRecorder)\par
\par
- Record interface should return false if it is still recording, and true if it is done\par
\par
- Then the MultiplexRecorder can have the smarts to create Tracks etc.\par
\tab - How does this actually work?  \par
\tab - We create a Track and hand it the streams from the DualRecorder.\par
\tab - Or *is* the Loopie the DualRecorder?  Yeah, what the hell, let's say so.\par
\tab - So the Loopie itself knows when to create a Track and what to create the Track with.\par
\tab - And it knows to remove itself from the MultiplexRecorder.\par
\par
So the MultiplexRecorder is the synchronization point.  It gets locked in the Record methods and in the Add(DualRecorder) method.  Which might as well be AddLoopie, perhaps, because not at all clear DualRecorder has any value as an interface.\par
\par
Yeah, let's just say it's the Holofunk class that serves the purpose of the MultiplexRecorder; keep all the locking in one top-level class.\par
\par
Alright, this seems clearer now.\par
 \tab Core.dll!Holofunk.Core.SliceFloatExtension.CopyToSlice<Holofunk.Core.Sample>(System.IntPtr src, Holofunk.Core.Slice<Holofunk.Core.Sample,float> dest) Line 377\tab C#\par
 \tab Core.dll!Holofunk.Core.BufferedSliceStream<Holofunk.Core.Sample,float>.Append(Holofunk.Core.Duration<Holofunk.Core.Sample> duration, System.IntPtr p) Line 146\tab C#\par
 \tab HolofunkBass.dll!Holofunk.HolofunkBassAsioInput.InputDspProc(int handle, int channel, System.IntPtr buffer, int lengthBytes, System.IntPtr user) Line 180\tab C#\par
 \tab [External Code]\tab\par
 \tab bass.dll!0000000180022ed4()\tab Unknown\par
 \tab bass.dll!0000000180023117()\tab Unknown\par
 \tab bass.dll!0000000180028732()\tab Unknown\par
 \tab bassmix.dll!0000000010503483()\tab Unknown\par
 \tab bass.dll!000000018002309b()\tab Unknown\par
 \tab bass.dll!0000000180028732()\tab Unknown\par
 \tab [External Code]\tab\par
>\tab HolofunkBass.dll!Holofunk.HolofunkBassAsio.MixerToOutputAsioProc(bool input, int channel, System.IntPtr buffer, int lengthBytes, System.IntPtr user) Line 117\tab C#\par
 \tab [External Code]\tab\par
 \tab bassasio.dll!00000000110040cd()\tab Unknown\par
 \tab bassasio.dll!00000000110048e8()\tab Unknown\par
 \tab bassasio.dll!000000001100513a()\tab Unknown\par
 \tab bassasio.dll!0000000011005443()\tab Unknown\par
 \tab ffusb2asio_x64.dll!000000005cb8a66e()\tab Unknown\par
 \tab ffusb2asio_x64.dll!000000005cb8989d()\tab Unknown\par
 \tab [External Code]\tab\par
\par
WHAT A WEIRD GODDAMN STACK *THAT* IS.\par
\par
\i THE INPUT IS MONO.\par
512 INPUT SAMPLES IN THE INPUTDSPPROC.  128 bufsize x 4 floatlen\par
1024 LENGTHBYTES IN THE MIXERTOOUTPUTASIOPROC.  128 bufsize x 2 stereo x 4 floatlen\par
\par
INPUT STREAM HAS *DIFFERENT* SLIVER SIZE AND POTENTIALLY *DIFFERENT* BUFFERALLOCATOR!\par
\i0\par
Actually why the hell does the BufferAllocator know anything ABOUT slivers?\par
It should just know about capacities and then leave the slivering up to the slice.\par
That way we can have one float BufferAllocator and get either stereo streams or mono streams from it -- more efficient, no risk of an exploding freelist of just one type.\par
Hell, if we did it right we could have just one kind of BufferAllocator and use TConverter?!?!?!?!\par
very interesting!!!!!  But no, not now.\par
\par
OK that seems much better.\par
Now latest problem: Shut is not happy because there is no trimming happening.\par
How is trimming supposed to happen?  Answer:  not... surrre.\par
\par
Yay trimming works!\par
Yay recorded loops stick to hand!\par
Yay audio keeps flowing!\par
Yay think I fixed loop volume!\par
Yay loop level works for recorded loops!\par
\par
- may need to perf profile the greenscreening.\par
\par
BUT, at least the ambidextrous interface worked the first time :-D\par
(wonder if there is any chance the instability is due to a new threading issue there....)\par
\par
So, current evidence is that the old Track code and its BUGBUG are known flaky.  Hit another assertion in there somewhere else tonight.\par
So there are certainly badnesses in the old Track code and it would be good to move it to the new streams anyway.  SO DO THAT FOR STABILITY.\par
\par
\par
Also, what is up with the occasional truncated video loops?  Saw one that had only five video frames despite being four measures long!  Another one right next to it with the same duration had hundreds of frames and looked as expected.  WTF?????  Some kind of early termination / targeting issue?  Hmm, experiment with video effect from early termination and/or starting a new one before previous one is fully terminated.\par
\par
Ah yes, all these issues coming back to me now, time to kill the fuck out of all of them and stress this thing like never before.  Give it a full week just for that, with lots of practicing.  Then one week left to get screen size, mike effects, and \par
\par
\par
\b MILESTONE: PROPER MEMORY RECLAMATION\par
\b0\par
- implement Stream<T>, BufferedDenseStream<T>, BufferedSparseStream<T>\par
\tab - implement DenseSlice<T> and SparseSlice<T>\par
\tab - also implement AbsoluteTime (samples since launch), RelativeTime (samples within bounded window)\par
\tab - implement TimeMapper interface with LoopingTimeMapper and DelayedTimeMapper\par
\par
Now what DOESN'T work is:\par
- GetLongestSliceAt is untested and of course broken.  Not only doesn't it work for the case where there is just one big slice, but it also doesn't chop down the returned slice to have the right initial offset -- it will return data starting before the requested mapped time.\par
\tab - Write fuckin' unit tests for it, but too tired now to understand the existing slicing test.\par
\tab - Then it might actually Just Work.....\par
\par
dON'T EVEN NEED IT AND IT'S NOT WELL DEFINED, JUST USE GETNEXTSLICEAT.\par
Who needs more than one second of buffer-ahead anyhow.\par
\par
NOW, assertion failure because the stream's initial time is long after the time it's being asked for.  WHY?\par
Interval requested: [494592, 48000]\par
Stream initial time: 373760\par
Stream duration: 128000\par
373760+128000=501760\par
\par
So the mapped interval should be from 494592 to 501760.\par
But no.  Its initial time is 120832 and duration is 7168.\par
\par
 That IS the proper duration but the WRONG initial time.\par
And it is the wrong initial time because... because the looping mapper was mapping everything onto a domain that went back to time 0.\par
But really it is better to think in terms of streams as being partial functions from time to signal; they start at time T and repeat forever (logically).\par
Then get into all kinds of temporal database-like questions about "when does something start or end" blah blah.  But anyway now it seems to play something back!\par
\par
\b WHY NO VIDEO ANIMATION???\par
- because video track is not shut!!!\par
\b0\tab YESSSSSSSSSSSSSSS\par
\par
Fix crappy m_lastNow introducing thread race.\par
Just pass the current moment down the render hierarchy, it is totally appropriate.\par
\par
WOOOOOOOOOOOOOW IT IS LOOKING LIKE IT KIND OF SORT OF ACTUALLY WORKS\par
got way more loops than have been able to get with the NUC yet!!!  with no ASIO stalls!!!!!\par
\par
and now whammo, the last assert of the night.  DIAGNOSE, THEN CRASH, BECAUSE THIS SHIT IS GETTING UP IN THE AIR.\par
\par
The assertion is because in Record, we have final continuous duration of 32000 but our stream is already 33440 or something.\par
\par
My assumption was that this could not happen because Record is the only thing that appends to the stream, so when the user requests to end at next beat, the next Record will catch it.\par
\par
What I obviously missed is that there can be an ASIO append operation racing with the user's stop-recording gesture.  So the user's stop-recording gesture can pick a continuous duration that is about to become obsolete.\par
\par
What is the right fix?  Seems clear that the race has to be closed somehow, probably by locking.  But that is for TOMORROW.\par
\par
\b DOES IT ACTUALLY RECORD SOUND?????  \i YESSSSSSSSSSSS\i0\par
\par
DOES THE SOUND ACTUALLY PLAY BACK?????????   \i YESSSSSSSSSSSSSSS\i0\par
\par
\b0\par
AND ANOTHER WEIRD ONE:  video sample stream asserts because it is getting two frames added with the SAME TIME.  Looks possible if there is no clock update between two calls to BodyFrameUpdate, but that seems hard to imagine why there would be no clock update???  Did ASIO just freeze?  LET'S HOPE NOT.  Mark it and fix it in a bit if it recurs.  First, DOES THE GODDAMN SOUND WORK?????\par
\par
\par
\par
Ahhh, some kind of deadlock?  Suddenly froze after starting recording:\par
\par
Not Flagged\tab >\tab 5068\tab 0\tab Worker Thread\tab ffusb2asio_x64.dll thread\tab Bass.Net.dll!Un4seen.Bass.Bass.BASS_FXSetParameters\tab Time Critical\par
 \tab  \tab  \tab  \tab  \tab  \tab [External Code]\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab HolofunkBass.dll!Holofunk.BassDX8Effect<Un4seen.Bass.BASS_DX8_FLANGER>.Apply() Line 127\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab HolofunkBass.dll!Holofunk.FlangerEffect.Apply(Holofunk.ParameterMap parameters, Holofunk.Core.Moment now) Line 199\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab HolofunkBass.dll!Holofunk.EffectSet.Apply(Holofunk.ParameterMap parameters, Holofunk.Core.Moment now) Line 39\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab HolofunkBass.dll!Holofunk.Track.StartPlaying(Holofunk.Core.Moment now) Line 121\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab Holofunk.exe!Holofunk.Loopie.Record(Holofunk.Core.Moment now, Holofunk.Core.Duration<Holofunk.Core.Sample> duration, System.IntPtr audioBuffer) Line 231\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab HolofunkBass.dll!Holofunk.HolofunkBassAsioInput.InputDspProc(int handle, int channel, System.IntPtr buffer, int lengthBytes, System.IntPtr user) Line 189\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab [External Code]\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bass.dll!0000000180022ed4()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bass.dll!0000000180023117()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bass.dll!0000000180028732()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bassmix.dll!0000000010503483()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bass.dll!000000018002309b()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bass.dll!0000000180028732()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab [External Code]\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab HolofunkBass.dll!Holofunk.HolofunkBassAsio.MixerToOutputAsioProc(bool input, int channel, System.IntPtr buffer, int lengthBytes, System.IntPtr user) Line 117\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab [External Code]\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bassasio.dll!00000000110040cd()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bassasio.dll!00000000110048e8()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bassasio.dll!000000001100513a()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab bassasio.dll!0000000011005443()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab ffusb2asio_x64.dll!000000005cb8a66e()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab ffusb2asio_x64.dll!000000005cb8989d()\tab  \par
 \tab  \tab  \tab  \tab  \tab  \tab [External Code]\tab  \par
\par
\par
Looks like doing all these BASS calls re-entrantly from the AsioProc might not be so hot after all, especially as this is already re-entrant.\par
\par
Repeatable?????  And need to be checking in more!!!!!  sigh\par
\par
OK, had to comment out that set-effects line after another freeze.  NOT YET SEEN ANY FURTHER SUCH FREEZES.  Wonder if that was the issue previously.  Jesus, was I lucky to get that stack!!!!!\par
\par
\par
OK, so this track problem (stopping recording and getting a target final duration that is less than the actual current duration) seems to be some kind of insanity around Moment, particularly in its Beats computation.  The ContinuousBeatDuration at 90 BPM is 32000, and the incoming discrete duration is 33600, so TrackBeatLength should clearly be 2.  But it is not; it is 1.  Why is this???\par
BECAUSE I MYSELF SAID THAT 0.05 BEATS OVER COULD BE TRIMMED!!!\par
Chop that shit RIGHT OUT.\par
\par
AND FIX TEXT WEIRDNESS:\par
- is it sharpdx 2.6.2 that fucked with fonts again?\par
- dunno... but kind of hard to see the CPU level without it!  And the CPU level is the #1 evil suspect in the ASIO fuckupery.\par
 \tab\tab - fuck it, just roll back to 2.5.0\par
- GAH!  Same problem with 2.5.0 but it was simply that arial16.xml isn't getting copied to Holofunk\\bin\\debug\\x64\\TextureContent.  Why not?!?!?!  Not sure, but OK to work around by just hand copy FOR NOW.\par
- and even THAT was not it.  Downloaded 2.6.2 samples and the SpriteBatchAndFont creates Arial.tkb which I have NEVER SEEN BEFORE.  But dragging it to [bindir]TextureOutput actually gets past the AssetNotFoundException!  Hacky but DO I CARE, NO!!!!!!!!!!\par
- had to roll forward again to 2.6.2 for the Samples-generated Arial16.tkb to work.  OH WELL!\par
- \b TEXT WORKING AGAIN!!!!!!!\b0\par
\par
\b Why the popup menus are all white?\par
\b0 Ay, it's because of severe confusion about the update flow.\par
Does it flow from parents to children, or children to parents?\par
The expected layered state machine approach (delegating to individual hand machines) argues for parent->child.\par
But the "model layering" approach to hierarchical models within a state machine argues for child->parent.\par
So let's do this:\par
- Basic model update is parent->child: HolofunkModel -> PlayerModel -> PlayerHandModel.StateMachine.Model.\par
- At hand level, it becomes child->parent -- the hand machine's GameUpdate will be called, which will call parentwards as appropriate -- but will NOT go from PlayerHandModel to PlayerMode.\par
\par
YAY FIXED!!!!!\par
\b\par
Why the lag?  Is initial latency compensation stream prepending not working?\par
\b0 Null hypothesis is that initial time is not being offset by latency compensation amount.  TRY THAT FIRST\par
YESSSSSSSSSSSSSSSSSSSSSSSSS!!!!!!!!!!!!!!!!!!!!!!\b\par
\par
\b0 Then, goddamn font won't load because SpriteFontData version [0x60] is not supported. Expecting [0x100]\par
WTF?  Even the sharpdx sample had the same problem.  Download the binary 2.5.0 distro.\par
\tab\b DONE!\b0\par
\b\par
MILESTONE: CLEAN UP TRACK-DONE EVENT\par
\par
\b0 - fix state machine weirdness around "waiting for track to finish recording"\par
\tab - TrackDone event is evil and must die (because it puts player input into a sort of limbo and definitely entails bugs)\par
\tab - need to understand what we really want the interaction to be -- should start recording before end of prior loop?  auto-pad with silence in that case?\par
\tab - maybe we DO need TrackDone after all... \par
\tab\tab\par
If we really don't want TrackDone, but we do want a newly recorded track to be flush with the previous track (whose duration was longer while the beat finished recording), then we need some other way to handle the situation where the user starts recording again before TrackDone.  How should the new recording be deferred?\par
\par
Perhaps there is a notion of a PENDING Track. Tracks can either be Recording, Looping, or Pending.  There is at most one track Recording (per hand) at any time, and there can only be at most one Pending track if there is currently a Recording track.\par
So the Pending track, if it exists, picks up seamlessly from the track that finishes Recording, and the mechanism for handling end-of-Recording is purely a BASS notification issue, not something visible to the state machine.\par
Yes I think I like that fine.\par
\par
make sure system can support two concurrently recorded tracks?!?!?!?!\par
\b YES.\b0\par
\par
- implement reference counting on chunks or sub-chunks or something similar\par
- proper free list, enqueue at one end, dequeue from the other \par
\tab - ensure thread safety in allocator of course\par
- cut back hugely on amount of audio buffer space\par
\par
\b MILESTONE: COLORED HEADSHOTS\b0\par
\par
- revise depth texturing code to integrate copying the head texture from the color stream\par
\tab - probaby revise the screen buffer to be in color space so as to get max color definition\par
\tab - sort out any pixel mapping hole issues\par
\par
\b MILESTONE: RECORD HEADSHOTS\par
\b0\par
- do some basic testing to see effect of many Texture2Ds on GC pressure\par
- do more benchmarking to assess speed of Texture2D copying\par
\tab - potentially background thread for Texture2D copying ahead of time?  or maybe not....\par
\par
- implement actual recorded headshot stream via standard Chunk infrastructure\par
- determine how much memory is needed for a reasonably lively scene\par
- if it all goes to hell performance-wise, then figure out a better way (texture copying to GPU? major SharpDX magic? main memory texturing on Intel GPU? -- would rather not do that last one....)\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
DONEDATE 2014/07/07:\par

\pard\b\f0\fs20\lang1033\par
AUDIO CLICKING.\par
\b0 Definitely new and definitely NOT NICE.\par
Is it related to the fancy interval mapping?  Can we just always do the simple thing there?\par
- TRY THAT FIRST (avoid fancy looping mapping).\par
- Add Audio spam and verify that our basic slice feeding is working properly (should see contiguous patterns of Slices going in, with AT MOST one sample off, and not even that if we avoid the looping mapping).\par
\tab - maybe add an assertion to this effect???  (at least until we get this nailed?  won't fly once have weirder mappings)\par
\par
...soooo, debugging this and it looks like we have an ASIO clock skip issue:\par
\tab\tab [10]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[\highlight4 1312128\highlight0 ]], pushing Slice[buffer Buf#1024[384000], offset D[48704], duration D[\highlight4 15296\highlight0 ], sliverSize 1]"\tab string\par
\tab\tab [11]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[1199424], D[64000]], input I[T[1327488], D[48000]], ret I[T[1199488], D[48000]]"\tab string\par
\tab\tab [12]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[\highlight4 1327488\highlight0 ]], pushing Slice[buffer Buf#1024[384000], offset D[\highlight4 64\highlight0 ], duration D[48000], sliverSize 1]"\tab string\par
\par
The problem is that 1312128 + 15296 = \highlight4 1327424\highlight0  which is indeed exactly 64 less than 1327488.  In other words, we push N samples (where N == 15296) into the stream, and we expect to get called back exactly that many samples later, but no: we actually get called back N + 64 samples later.  So we get a clear glitch of 64 samples at the wrap point.\par
\par
So WHY do we get this clock skip?  Speculation: we have some kind of race in advancing Clock.Now, especially as we now know that the input sync procs get called re-entrantly from the MixerToOutputAsioProc.\par
\b\par
\par
Staying on target:\b0\par
\tab\tab [1075]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[790016]]"\tab string\par
\tab\tab [1076]\tab "BufferedSliceStream.Shut: next slice time T[724800], slice Slice[buffer Buf#1023[384000], offset D[0], duration D[64000], sliverSize 1]"\tab string\par
\tab\tab [1077]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[724800], D[64000]], input I[T[790016], D[48000]], ret I[T[726016], D[48000]]"\tab string\par
\tab\tab [1078]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[790016]], pushing Slice[buffer Buf#1023[384000], offset D[1216], duration D[48000], sliverSize 1]"\tab string\par
\tab\tab [1079]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[790144]]"\tab string\par
...\par
\tab\tab [1452]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[837888]]"\tab string\par
\tab\tab [1453]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[724800], D[64000]], input I[T[837888], D[48000]], ret I[T[773888], D[14912]]"\tab string\par
\par
CHECK: 790016 + 48000 = 838016.  But note that the advancement to that time comes AFTER the input syncproc!!!  It is driven by a PULL from the MixerToOutputAsioProc's GetData call!!!\par
\par
So really we should advance the time BEFORE we call GetData???  Because that is the time we are getting data FOR?????\par
\par
Let's try.\par
\par
\tab\tab [1493]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[523392]]"\tab string\par
\tab\tab [1494]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[410304], D[64000]], input I[T[523520], D[48000]], ret I[T[459520], D[14784]]"\tab string\par
\tab\tab [1495]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[523520]], pushing Slice[buffer Buf#1020[384000], offset D[49216], duration D[14784], sliverSize 1]"\tab string\par
\tab\tab [1496]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[523520]]"\tab string\par
...\par
\tab\tab [1611]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[538240]]"\tab string\par
\tab\tab [1612]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[410304], D[64000]], input I[T[538368], D[48000]], ret I[T[410368], D[48000]]"\tab string\par
\tab\tab [1613]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[538368]], pushing Slice[buffer Buf#1020[384000], offset D[64], duration D[48000], sliverSize 1]"\tab string\par
\tab\tab [1614]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[538368]]"\tab string\b\par
\b0\par

\pard\sl240\slmult1\f8\fs16\lang9\tab\tab [490]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[484992]]"\tab string\par
\tab\tab [491]\tab "BufferedSliceStream.Shut: next slice time T[419648], slice Slice[buffer Buf#1020[384000], offset D[0], duration D[64000], sliverSize 1]"\tab string\par
\tab\tab [492]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[419648], D[64000]], input I[T[484992], D[48000]], ret I[T[420992], D[48000]]"\tab string\par
\tab\tab [493]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[484992]], pushing Slice[buffer Buf#1020[384000], offset D[1344], duration D[48000], sliverSize 1]"\tab string\par
\tab\tab [494]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[485120]]"\tab string\par
...\par
\tab\tab [867]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[532864]]"\tab string\par
\tab\tab [868]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[419648], D[64000]], input I[T[532864], D[48000]], ret I[T[468864], D[14784]]"\tab string\par
\tab\tab [869]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[532864]], pushing Slice[buffer Buf#1020[384000], offset D[49216], duration D[14784], sliverSize 1]"\tab string\par
\tab\tab [870]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[532992]]"\tab string\par
...\par
\par
485120 + 48000 = 533120.  But note that MixerToOutputAsioProc is NOT THERE YET.\par
\par
Really starting to look like I was right in the first place to push the new track's data from the ASIO thread :-(\par
Either that or I need some ASIO synchronization...\par
...let's try the synchronization first.....\par
\par
..ugh!  It *is* already synchronized!!!\par
Or rather, it's already being called on the ASIO thread.  CRAP.\par
\par
\par
\par
\par
\tab\tab [1026]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[464000]]"\tab string\par
\tab\tab [1027]\tab "BufferedSliceStream.Shut: next slice time T[399040], slice Slice[buffer Buf#1020[384000], offset D[0], duration D[64000], sliverSize 1]"\tab string\par
\tab\tab [1028]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[399040], D[64000]], input I[T[464000], D[48000]], ret I[T[400000], D[48000]]"\tab string\par
\tab\tab [1029]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[464000]], pushing Slice[buffer Buf#1020[384000], offset D[960], duration D[48000], sliverSize 1]"\tab string\par
\tab\tab [1030]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[464128]]"\tab string\par
...\par
\tab\tab [1403]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[511872]]"\tab string\par
\tab\tab [1404]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[399040], D[64000]], input I[T[511872], D[48000]], ret I[T[447872], D[15168]]"\tab string\par
\tab\tab [1405]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[511872]], pushing Slice[buffer Buf#1020[384000], offset D[48832], duration D[15168], sliverSize 1]"\tab string\par
\tab\tab [1406]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[512000]]"\tab string\par
...\par
\tab\tab [1524]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[527104]]"\tab string\par
\tab\tab [1525]\tab "SimpleLoopingIntervalMapper.MapNextSubInterval: m_stream BufferedSliceStream[T[399040], D[64000]], input I[T[527104], D[48000]], ret I[T[399104], D[48000]]"\tab string\par
\tab\tab [1526]\tab "Track #0 PushNextSliceToAsioMixer: at Moment[T[527104]], pushing Slice[buffer Buf#1020[384000], offset D[64], duration D[48000], sliverSize 1]"\tab string\par
\tab\tab [1527]\tab "MixerToOutputAsioProc: now advanced by 128 to Moment[T[527232]]"\tab string\par
...\par
\par
464000 + 48000 = 512000.  But this time the track gets advanced BEFORE the clock gets moved to 512000.  We would expect/hope/want that every time MapNextSubInterval is called, the Now time is exactly advanced by how many samples we last pushed.  But this is empirically not the case.\par
\par
Did we handle this better previously in some sneaky way I've now forgotten???\par
\par
AHA!!!  We didn't previously pay any attention to Now at all!!!!!\par
\par
So if we really want to be time-based here, then we need to push the samples regardless of exact details of Now.\par
Fine, let's give Track its own "internal Now".\par

\pard\f0\fs20\lang1033\par
OK that's better.\par
\par
\b Can audio streams actually be freed, without risking fatal races with ASIO procs?\b0\par
Basic plan is to make track dispose null out the audio stream (under a this-Track-lock).  Likewise, audio playback will be under a this-Track-lock as well so we won't collide on dispose.\par
\par
Let's try it and reduce the amount of audio buffer (and increase video buffer).\par
\par
YAY!!! Finally works to release audio data!  Infinite recording ahoy....\par
\par
\par
\b ADD COMMAND TO START SAVING WAV TO DISK\par
\b0 and don't do it at all (and put up warning) if <10% free space.\par
- DONE\par
\b\fs36\par
\b0\fs20 - verify second monitor output from NUC actually works - FUCKING YAY IT DOES!!!!!!!\par
\par
\par
\par
\par
\b\par
WHY THE HELL DOES IT SOMETIMES START UP WITH HALF-SPEED SHIT AUDIO??!?!?!?!?!?!?!?!?\par
haven't seen it happen \i after\i0  startup yet with latest NUC stable....\par
OHHHHHHHH YES I HAVE.  Dammit.\line BUT BUT BUT, fascinating new data, seems like the WAV file was fine right to the end!\par
AND, seems like killing Windows Audio Device Graph Isolation does improve stability SOMEWHAT.\par
\i AND, UNPLUG THE WIRELESS USB INTERNET DONGLE AND PLUG THE 6i6 INTO THE NUC FRONT.\i0\par
- Add spam for tracking ASIO callback interval and wall-clock average time\par
- Capture normal timing\par
- When slowdown happens, capture what timing is then\par
- Also, make some unmistakable change in the audio recording so it's clear whether the slowdown portion got recorded\par
- ALSO, videotape the thing so the visual behavior and sound are both captured\par
\par
BUT FOR TONIGHT, FUUUUUUCK IT.\b0\par
\par
\ul\b BUT STILL HITTING THE GODDAMNED ASIO FREEZING BUG SOMETIMES\par
Added code to track number of GCs.  Forcing GCs on every ASIO callback does NOT hose things right away except for ASIO sound quality -- does not cause major slowdown.\par
WHAT COULD IT BE?????????????????????\ulnone\b0\par
\par

\pard\sb100\sa100\f2\fs24 Hello Rob,\line\line Thank you for your email.\line\line This sounds like you may be having a DPC Latency Issue.\line\line First make sure you have run all the following Optimization Steps:\line {{\field{\*\fldinst{HYPERLINK http://global.focusrite.com/answerbase/optimising-your-pc-for-audio-on-windows-7?id=1071 }}{\fldrslt{http://global.focusrite.com/answerbase/optimising-your-pc-for-audio-on-windows-7?id=1071\ul0\cf0}}}}\f2\fs24\line {{\field{\*\fldinst{HYPERLINK http://global.focusrite.com/answerbase/optimising-your-pc-for-audio-on-windows-8 }}{\fldrslt{http://global.focusrite.com/answerbase/optimising-your-pc-for-audio-on-windows-8\ul0\cf0}}}}\f2\fs24\line\line Next can you download this program, LatencyMon, and run it while playing back audio at the same time, making sure to actually replicate the drop out or disconnect problem.\line\line {{\field{\*\fldinst{HYPERLINK http://www.resplendence.com/latencymon }}{\fldrslt{http://www.resplendence.com/latencymon\ul0\cf0}}}}\f2\fs24\line\line After replication click Edit Copy report to clipboard. Paste this into a NotePad and save it. Send that in your reply.\line\line Please also go to the Drivers Tab, sort by Highest Execution, with the highest on top, and send a Screenshot of that page. {{\field{\*\fldinst{HYPERLINK http://www.wikihow.com/Take-a-Screenshot-in-Microsoft-Windows }}{\fldrslt{http://www.wikihow.com/Take-a-Screenshot-in-Microsoft-Windows\ul0\cf0}}}}\f2\fs24\line\line Also go to the Processes Tab, sort by Hard Pagefaults, with the highest on top, and send a Screenshot of that page.\line\line Could you send a copy of your system information as an nfo file with your reply to this e-mail please? To obtain this file, navigate to:\line From the Desktop Right Click the Start/Window Box Control Panel Set View By to Small Icons Administrative Tools System Information Save as... Make sure to use NFO File Type\line\line Also please feel welcome to try out our Beta Version of the MixControl and new Beta Windows Driver we are working on here:\line {{\field{\*\fldinst{HYPERLINK http://beta.focusrite.com/ }}{\fldrslt{http://beta.focusrite.com/\ul0\cf0}}}}\f2\fs24\line\line Please let me know how you come along.\line\line Best regards.\line\line --\line Katherine Kaplan // Focusrite Technical Support\par

\pard\f0\fs20\par
\par
\par
\par
OK, so I had already done all that.\par
EXCEPT THAT I discovered "SM Bus Controller" had a yellow ! in Device Manager.  Not good.\par
So running Intel Chipset Drivers Install app per internet.\par
And it resolved in device manager without even a reboot!  Nice.\par
AND disabling Kinect NUI Microphone Array in Device Manager too, just for shits and giggles.\par
\par
AND turned off "shut down this USB port when sleeping" on both USB root hubs.\line AND disabled "Background Intelligent Transfer Service" service\par
AND disabled all "Remote Desktop" services\par
AND disabled "Windows Firewall" (gulp)\par
\tab but it restarted by itself.\par
\par
AND tried shrinking Holofunk window....\par
\tab ...AND IT WORKED BETTER.\par
\tab previously was hanging \i instantly.\i0\par
\par
W T F IS GOING ONNNNNN\par
\par
\b BETA DRIVER SEEMS TO HELP \i A LOT\i0\line TEST THE SHIT OUT OF IT TONIGHT BEFORE MONSTER PLANET\b0\par
\par
\par
\par
- try shrinking the heads and loops a bit - DONE\par
\par
\par
FULL RESOLUTION COLOR:  sigh, insane frame rate hit.\par
Need to shelve this if possible and roll back to prior version and use Stopwatch for time diff.\par
Here's the spam; note multiple Updates in between each Render, which is Just Wrong.\par
\par
\par
\tab\tab [1357]\tab "UpdateDisplayTexture: copy msec 15, mapClear 14, loop 37, set 1"\tab string\par
\tab\tab [1358]\tab "UpdateDisplayTexture: copy msec 12, mapClear 11, loop 35, set 3"\tab string\par
\tab\tab [1359]\tab "UpdateDisplayTexture: copy msec 13, mapClear 12, loop 36, set 4"\tab string\par
\tab\tab [1360]\tab "EndUpdate"\tab string\par
\tab\tab [1361]\tab "Root: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1362]\tab "    Background: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1363]\tab "    ViewportNode: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1364]\tab "    Track group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1365]\tab "    Player #0: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1366]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1367]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1368]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.6,0.6)"\tab string\par
\tab\tab [1369]\tab "                TrackHighlight: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1370]\tab "                TrackSound: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1371]\tab "                Headshot: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [1280,-24 - 1328,24]"\tab string\par
\tab\tab [1372]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1373]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1374]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1375]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1376]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1377]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1378]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1379]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1380]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1381]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1382]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1383]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1384]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1385]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1386]\tab "    Player #1: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1387]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1388]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1389]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.6,0.6)"\tab string\par
\tab\tab [1390]\tab "                TrackHighlight: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [1304,0]x(0.05818415,0.05818415); start rect [-50,-50 - 50,50]; transformedRect [1301,-2 - 1306,2]"\tab string\par
\tab\tab [1391]\tab "                TrackSound: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [1304,0]x(0.02818415,0.02818415); start rect [-50,-50 - 50,50]; transformedRect [1302,-1 - 1305,1]"\tab string\par
\tab\tab [1392]\tab "                Headshot: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [1280,-24 - 1328,24]"\tab string\par
\tab\tab [1393]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1394]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1395]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1396]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [1304,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [1302,-1 - 1305,1]"\tab string\par
\tab\tab [1397]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [1304,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [1303,0 - 1304,0]"\tab string\par
\tab\tab [1398]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1399]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1400]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1401]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1402]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1403]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [1304,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [1302,-1 - 1305,1]"\tab string\par
\tab\tab [1404]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [1304,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [1303,0 - 1304,0]"\tab string\par
\tab\tab [1405]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1406]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1407]\tab "End Render"\tab string\par
\tab\tab [1408]\tab "Root: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1409]\tab "    Background: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1410]\tab "    ViewportNode: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1411]\tab "    Root Beater: parentTransform [0,0]x(1,1), localTransform [652,945]x(1,1), combinedTransform [652,945]x(1,1), color A:255 R:255 G:255 B:255"\tab string\par
\tab\tab [1412]\tab "        Root Beater: beat 0, filledness 0, destRect X:665 Y:970 Width:25 Height:25"\tab string\par
\tab\tab [1413]\tab "        Root Beater: beat 1, filledness 0, destRect X:640 Y:970 Width:25 Height:25"\tab string\par
\tab\tab [1414]\tab "        Root Beater: beat 2, filledness 0, destRect X:640 Y:945 Width:25 Height:25"\tab string\par
\tab\tab [1415]\tab "        Root Beater: beat 3, filledness 0.16, destRect X:665 Y:945 Width:25 Height:25"\tab string\par
\tab\tab [1416]\tab "    Track group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1417]\tab "    Player #0: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1418]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1419]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1420]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1421]\tab "                TrackHighlight: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1422]\tab "                TrackSound: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1423]\tab "                Headshot: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [-24,-24 - 24,24]"\tab string\par
\tab\tab [1424]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1425]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1426]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1427]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1428]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1429]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1430]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1431]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1432]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1433]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1434]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1435]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1436]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1437]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1438]\tab "    Player #1: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1439]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1440]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1441]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1442]\tab "                TrackHighlight: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [0,0]x(0.05818415,0.05818415); start rect [-50,-50 - 50,50]; transformedRect [-2,-2 - 2,2]"\tab string\par
\tab\tab [1443]\tab "                TrackSound: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [0,0]x(0.02818415,0.02818415); start rect [-50,-50 - 50,50]; transformedRect [-1,-1 - 1,1]"\tab string\par
\tab\tab [1444]\tab "                Headshot: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [-24,-24 - 24,24]"\tab string\par
\tab\tab [1445]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1446]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1447]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1448]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [0,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [-1,-1 - 1,1]"\tab string\par
\tab\tab [1449]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [0,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [0,0 - 0,0]"\tab string\par
\tab\tab [1450]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1451]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1452]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1453]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1454]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1455]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [0,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [-1,-1 - 1,1]"\tab string\par
\tab\tab [1456]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [0,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [0,0 - 0,0]"\tab string\par
\tab\tab [1457]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1458]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1459]\tab "End Render"\tab string\par
\tab\tab [1460]\tab "UpdateDisplayTexture: copy msec 11, mapClear 13, loop 36, set 2"\tab string\par
\tab\tab [1461]\tab "UpdateDisplayTexture: copy msec 12, mapClear 11, loop 37, set 3"\tab string\par
\tab\tab [1462]\tab "UpdateDisplayTexture: copy msec 10, mapClear 11, loop 34, set 2"\tab string\par
\tab\tab [1463]\tab "EndUpdate"\tab string\par
\tab\tab [1464]\tab "Root: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1465]\tab "    Background: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1466]\tab "    ViewportNode: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1467]\tab "    Track group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1468]\tab "    Player #0: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1469]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1470]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1471]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.6,0.6)"\tab string\par
\tab\tab [1472]\tab "                TrackHighlight: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1473]\tab "                TrackSound: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1474]\tab "                Headshot: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [1280,-24 - 1328,24]"\tab string\par
\tab\tab [1475]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1476]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1477]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1478]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1479]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1480]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1481]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1482]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1483]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1484]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1485]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1486]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [1304,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1487]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1488]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1489]\tab "    Player #1: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1490]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1491]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1492]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.6,0.6)"\tab string\par
\tab\tab [1493]\tab "                TrackHighlight: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [1304,0]x(0.05818415,0.05818415); start rect [-50,-50 - 50,50]; transformedRect [1301,-2 - 1306,2]"\tab string\par
\tab\tab [1494]\tab "                TrackSound: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [1304,0]x(0.02818415,0.02818415); start rect [-50,-50 - 50,50]; transformedRect [1302,-1 - 1305,1]"\tab string\par
\tab\tab [1495]\tab "                Headshot: parentTransform [1304,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [1280,-24 - 1328,24]"\tab string\par
\tab\tab [1496]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1497]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1498]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1499]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [1304,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [1302,-1 - 1305,1]"\tab string\par
\tab\tab [1500]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [1304,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [1303,0 - 1304,0]"\tab string\par
\tab\tab [1501]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1502]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1503]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1504]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1505]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [1304,0]x(0.36,0.36)"\tab string\par
\tab\tab [1506]\tab "                    TrackHighlight: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [1304,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [1302,-1 - 1305,1]"\tab string\par
\tab\tab [1507]\tab "                    TrackSound: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [1304,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [1303,0 - 1304,0]"\tab string\par
\tab\tab [1508]\tab "                    Headshot: parentTransform [1304,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [1304,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [1289,-14 - 1318,14]"\tab string\par
\tab\tab [1509]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1510]\tab "End Render"\tab string\par
\tab\tab [1511]\tab "Root: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1512]\tab "    Background: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1513]\tab "    ViewportNode: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [0,0 - 1304,1080]; transformedRect [0,0 - 1304,1080]"\tab string\par
\tab\tab [1514]\tab "    Root Beater: parentTransform [0,0]x(1,1), localTransform [652,945]x(1,1), combinedTransform [652,945]x(1,1), color A:255 R:255 G:255 B:255"\tab string\par
\tab\tab [1515]\tab "        Root Beater: beat 0, filledness 0.872, destRect X:665 Y:970 Width:25 Height:25"\tab string\par
\tab\tab [1516]\tab "        Root Beater: beat 1, filledness 0, destRect X:640 Y:970 Width:25 Height:25"\tab string\par
\tab\tab [1517]\tab "        Root Beater: beat 2, filledness 0, destRect X:640 Y:945 Width:25 Height:25"\tab string\par
\tab\tab [1518]\tab "        Root Beater: beat 3, filledness 0, destRect X:665 Y:945 Width:25 Height:25"\tab string\par
\tab\tab [1519]\tab "    Track group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1520]\tab "    Player #0: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1521]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1522]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1523]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1524]\tab "                TrackHighlight: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1525]\tab "                TrackSound: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1526]\tab "                Headshot: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [-24,-24 - 24,24]"\tab string\par
\tab\tab [1527]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1528]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1529]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1530]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1531]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1532]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1533]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1534]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1535]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1536]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1537]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1538]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(-Infinity,-Infinity), combinedTransform [0,0]x(-Infinity,-Infinity); start rect [-50,-50 - 50,50]; transformedRect [-2147483648,-2147483648 - -2147483648,-2147483648]"\tab string\par
\tab\tab [1539]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1540]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1541]\tab "    Player #1: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1542]\tab "        Head group: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1543]\tab "            Head: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1); start rect [-26,-37 - 27,38]; transformedRect [-26,-37 - 27,38]"\tab string\par
\tab\tab [1544]\tab "            MikeSignal: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1545]\tab "                TrackHighlight: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [0,0]x(0.05818415,0.05818415); start rect [-50,-50 - 50,50]; transformedRect [-2,-2 - 2,2]"\tab string\par
\tab\tab [1546]\tab "                TrackSound: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [0,0]x(0.02818415,0.02818415); start rect [-50,-50 - 50,50]; transformedRect [-1,-1 - 1,1]"\tab string\par
\tab\tab [1547]\tab "                Headshot: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.48,0.48); start rect [-50,-50 - 50,50]; transformedRect [-24,-24 - 24,24]"\tab string\par
\tab\tab [1548]\tab "        Right Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1549]\tab "            Left Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1550]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1551]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [0,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [-1,-1 - 1,1]"\tab string\par
\tab\tab [1552]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [0,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [0,0 - 0,0]"\tab string\par
\tab\tab [1553]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1554]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1555]\tab "        Left Hand: parentTransform [0,0]x(1,1), localTransform [0,0]x(1,1), combinedTransform [0,0]x(1,1)"\tab string\par
\tab\tab [1556]\tab "            Right Group: parentTransform [0,0]x(1,1), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1557]\tab "                MikeSignal: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(0.6,0.6), combinedTransform [0,0]x(0.36,0.36)"\tab string\par
\tab\tab [1558]\tab "                    TrackHighlight: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.09697358,0.09697358), combinedTransform [0,0]x(0.03491049,0.03491049); start rect [-50,-50 - 50,50]; transformedRect [-1,-1 - 1,1]"\tab string\par
\tab\tab [1559]\tab "                    TrackSound: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.04697358,0.04697358), combinedTransform [0,0]x(0.01691049,0.01691049); start rect [-50,-50 - 50,50]; transformedRect [0,0 - 0,0]"\tab string\par
\tab\tab [1560]\tab "                    Headshot: parentTransform [0,0]x(0.36,0.36), localTransform [0,0]x(0.8,0.8), combinedTransform [0,0]x(0.288,0.288); start rect [-50,-50 - 50,50]; transformedRect [-14,-14 - 14,14]"\tab string\par
\tab\tab [1561]\tab "                Effect label group: parentTransform [0,0]x(0.6,0.6), localTransform [0,0]x(1,1), combinedTransform [0,0]x(0.6,0.6)"\tab string\par
\tab\tab [1562]\tab "End Render"\tab string\par
\tab\tab [1563]\tab "UpdateDisplayTexture: copy msec 11, mapClear 12, loop 36, set 1"\tab string\par
\tab\tab [1564]\tab "UpdateDisplayTexture: copy msec 10, mapClear 9, loop 33, set 2"\tab string\par
\par
\par
Also note about 63 msec for one UpdateDisplayTexture.  That just ain't gonna cut it.  Will have to stay at lower resolution.  But let's try shelving it....\par
\par
WHAT THE HELL!  The original code is FLYING.  0 msec for copy, 1 msec for map-and-clear, 3 msec for loop.  WHY is the viewport-resized code so INSANELY BAD?!?!?!?!  What exactly is causing the radical stopwatch differences?!?!?!\par
\par
\par
m_depthFrameData: 217088\par
m_colorFrameData: 8294400\par
m_bodyIndexFrameData: 217088\par
\par
Same goddamn sizes.  Same goddamn calls!  Why sooooo insanely slooooow!?????\par
\par
\par
\b MILESTONE: FULL-SCREEN SUPPORT ON EACH MONITOR\par
\b0\par
- resizable / maximizable game windows???  (does SharpDX toolkit support such?)\par
- press "esc" to go into / out of full-screen mode\par
\par
\par
- try out new d-fine!!!\par
\par
\b - JIGSAW RENAISSANCE DEMO NIGHT\b0\par
\par
\line also figure out what the FUCK is up with the Scarlett monitoring the mike inputs live, unless I turn down the monitor dial int he lower right of the MixControL UI, in which case I hear NOTHING live from the microphone!  AND nothing from Holofunk at all!  What is the deal here????\par
- answer: "DAW Preset" mode or whatever it is from the routing menu\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
DONEDATE 2015/01/25:\par

\pard\f0\fs20\lang1033 - fix currently recorded loopie showing new headshot video behind (colossal?!) loop gain circle\par
\b\tab DONE\b0\par
\par
- fix touched-loop highlighting\par
\tab - should be fixed now; problem was updating loopies then players, rather than other way around\par
\tab - \b TEST THIS - DONE\b0\par
\par
- fix beat node not showing for loopie in Record condition\par
\tab - \b TEST THIS - DONE\b0\par
\par
\par
\b FIX MIKE EFFECTS\b0\par
- "mouth" arm pose\par
- in mouth pose, go into effect menu selection with IsMicrophoneSelected enabled\par
\tab - \b DONE \b0\par
\par
\b FIX EFFECT MODALITY\par
\b0 - when in effect menu, hand goes direct to effect mode\par
- get rid of "hand mode" persistent field in player model\par
- need to add support for passing exit event to state machine transition handler\par
\tab - through the whole chain???  ...yeah why not\par
- then hand exit (only!) from menu state goes straight to effect mode for THAT effect\par
\tab - which effect?  sigh, still need some "effect mode" in player model after all\par
\tab - OK so it is just effect sets rather than "hand mode"\par
\par
\tab - \b DONE!!!\b0\par
\par
- support window resizing\par
\tab - do any SharpDX samples show this?\par
\tab - try making app render into single texture that then gets rescaled\par
\tab\tab - avoid duplicate renders to separate window\par
\tab\tab - avoid rendering multiple sprites to large backing buffers\par
\b\tab - DONE!!!!!!!\b0\par
\par
- upgrade to latest Kinect SDK drop\par
- upgrade color video to capture at color resolution\par
\tab - use same viewport aspect ratio\par
- Revise CoordinateBodyBasics sample to use color-to-depth rather than depth-to-color.\par
Investigate resulting timings.\par
\par
\par
- figure out how to get build to put Arial16.tkb in [bindir]\\TextureContent\par
\tab - probably need to include right SharpDX.Targets in Holofunk.csproj\par
\tab - see exactly how SpriteBatchAndFont sample (in NUC Downloads dir) does it\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par

\pard\f0\fs20\lang1033 - touch up the headshot size (shrink it) \b DONE\b0\par
- touch up the touched-loopie radius (grow it) \b DONE\b0\par
 \par
\par
- WHY THE FUCK DOESN'T TURNADO SOUND RIGHT?!?!?!?!?!?!\par
\tab - try 44.1 sample rate just in case\par
\tab - seems that the program setting isn't actually working???\par
\par
- looks like Turnado was set to wrong program in its UI, and setting through VST interface not effective :-((((\par
\par
- WHY TURNADO DYING IN STANDALONE TESTBED?\par
- DLLs from Bernd don't help ARRRRGH\par
\par
- still doing it but at least I figured out how to trap System.AccessViolationException.\par
\tab - and turn on native debugging to see those frames\par
- what the F is Bernd's app doing\par
- are there any .NET x64 VST hosts out there\par
\par
\par
- try taking Turnado out specifically but leaving VST on - works fine\par
- try swapping other (free) x64 VSTs if any at all exist - they do but arrrgh the configuration hassle and they sound crap\par
\par
- really dig into free effect situation, especially x64 Windows - splice.com turned up mostly fuck all, nothing compared to Turnado certainly\par
\par
- ask at MSFT about getting symbols to ntdll.dll etc :-P - thanks to Ian for sorting that one\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
DONEDATE 2015/04/15:\par

\pard\f0\fs20\lang1033 - BASSASIOTURNADOTEST x86 VS x64 PARAMETER COMPARISON\par
- DOES IT BUILD FOR x86?\par
\par
- FIRST BASS_VST FOR x86 - \b DONE!\b0\par
THEN CHECK IN\par
\par
- now try Win32 bass_vst.dll with x86 BATT\par
\tab - *********IT WORKS******\par
\par
So that is REALLY REALLY GOOD.  Bound to get it now!!!\par
\par
Unfortunately seems like something is still wrong with bass_vst Win32 flavor because source lines are wrong; not lining up with breakpoints.  Makes it very hard to know if any data is reliable, or exactly where crashes are ocurring.  And tiiiired now.  BUT REAL GOOD PROGRESS!\par
\par
\par
So yeah 64-bit is really truly 64.bit.\par
The exception is\par
\cf9\highlight10\f5\fs16 First-chance exception at 0x00007FFCFE0ABF9E (Turnado.dll) in BASSASIOTurnadoTest.exe: 0xC0000005: Access violation reading location 0x0000000057290240.\cf0\highlight0\f0\fs20\par
\par
So that location is seemingly unrelated to buffersIn and buffersOut.\par
+\tab\tab buffersIn\tab 0x0000000c5728ffa8 \{0x0000000c5728e1b0 \{6.51094448e-032\}, 0x0000000c5728e640 \{0.000000000\}, 0x0000000000000000 \{...\}, ...\}\tab float *[0x00000020]\par
+\tab\tab buffersOut\tab 0x0000000c572900a8 \{0x0000000c5728ead0 \{6.51094448e-032\}, 0x0000000c5725f4b0 \{0.000000000\}, 0x0000000000000000 \{...\}, ...\}\tab float *[0x00000020]\par
\par
WOW REALLY INTERESTING!  Breakpointing in audioMasterCallbackImpl yields A TON of insight into Turnado.\par
\par
\f8\fs16 >\tab bass_vst.dll!audioMasterCallbackImpl(AEffect * aeffect_, int opcode, int index, __int64 value, void * ptr, float opt) Line 252\tab C++\par
 \tab Turnado.dll!AudioEffectX::updateDisplay() Line 929\tab C++\par
 \tab Turnado.dll!SBPluginBase::updateDisplay() Line 126\tab C++\par
 \tab Turnado.dll!SBUniClient::load(SBChunk & chunk, int engine, bool byHost, bool bSilent, bool byPrgChange) Line 1288\tab C++\par
 \tab Turnado.dll!SBUniClient::load(char * externpath, int engine, char * presetformat, char * desc) Line 1417\tab C++\par
 \tab Turnado.dll!SBUniClient::SBUniClient(__int64 (AEffect *, int, int, __int64, void *, float) * audioMaster, int flavor, bool bAudioUnit) Line 308\tab C++\par
 \tab Turnado.dll!createEffectInstance(__int64 (AEffect *, int, int, __int64, void *, float) * audioMaster) Line 16\tab C++\par
 \tab Turnado.dll!VSTPluginMain(__int64 (AEffect *, int, int, __int64, void *, float) * audioMaster) Line 37\tab C++\par
 \tab bass_vst.dll!loadVstLibrary(BASS_VST_PLUGIN * this_, const void * dllFile, unsigned long createFlags) Line 487\tab C++\par
 \tab bass_vst.dll!BASS_VST_ChannelSetDSP(unsigned long channelHandle, const void * dllFile, unsigned long createFlags, int priority) Line 612\tab C++\par
\f0\fs20\par
hmm can listen for BASS_VST_PARAM_CHANGED!  Hook up Turnado UI this way???\par
\par
!!!!!AHA!!!!!!\par
\par
\f8\fs16 >\tab bass_vst.dll!audioMasterCallbackImpl(AEffect * aeffect_, int opcode, int index, __int64 value, void * ptr, float opt) Line 252\tab C++\par
 \tab\highlight4 Turnado.dll!AudioEffectX::getTimeInfo(int filter) Line 342\tab C++\par
\highlight0  \tab Turnado.dll!SBUniClient::processReplacing(float * * inputs, float * * outputs, int sampleFrames) Line 809\tab C++\par
 \tab Turnado.dll!AudioEffect::processClassReplacing(AEffect * e, float * * inputs, float * * outputs, int sampleFrames) Line 61\tab C++\par
 \tab bass_vst.dll!callProcess(BASS_VST_PLUGIN * this_, BASS_VST_PLUGIN * buffers, long numSamples) Line 325\tab C++\par
 \tab bass_vst.dll!doEffectProcess(unsigned long dspHandle, unsigned long channelHandle, void * buffer__, unsigned long bufferBytes__, void * vstHandle__) Line 494\tab C++\par
 \tab bass.dll!00007ffd1aed3bf6()\tab Unknown\par
 \tab bass.dll!00007ffd1aed3e3f()\tab Unknown\par
 \tab bass.dll!00007ffd1aed9c7e()\tab Unknown\par
 \tab bassmix.dll!00007ffd1bd4339b()\tab Unknown\par
 \tab bass.dll!00007ffd1aed3dc3()\tab Unknown\par
 \tab bass.dll!00007ffd1aed9c7e()\tab Unknown\par
 \tab [External Code]\tab\par
 \tab HolofunkBass.dll!Holofunk.HolofunkBassAsio.MixerToOutputAsioProc(bool input, int channel, System.IntPtr buffer, int lengthBytes, System.IntPtr user) Line 166\tab C#\par
\f0\fs20\par
calcVstTimeInfo(BASS_VST_PLUGIN* this_ = 0x000000eafeecc780, VstIntPtr toCalc = 0x0000000000001e02)\par
\par
0x1e02 = binary 0001111000000010\par
\par
kVstTransportPlaying & kVstPpqPosValid & kVstTempoValid & kVstBarsValid & kVstCyclePosValid\par
\par
\par
\cf1\highlight8\f5\fs16 enum\cf7  \cf2 VstTimeInfoFlags\cf7\par
\{\par
\cf6 //-------------------------------------------------------------------------------------------------------\cf7\par
\tab\cf11 kVstTransportChanged\cf7      = 1,\tab\tab\cf6 ///< indicates that play, cycle or record state has changed\cf7\par
\tab\cf11 kVstTransportPlaying\cf7      = 1 << 1,\tab\cf6 ///< set if Host sequencer is currently playing\cf7\par
\tab\cf11 kVstTransportCycleActive\cf7  = 1 << 2,\tab\cf6 ///< set if Host sequencer is in cycle mode\cf7\par
\tab\cf11 kVstTransportRecording\cf7    = 1 << 3,\tab\cf6 ///< set if Host sequencer is in record mode\cf7\par
\tab\cf11 kVstAutomationWriting\cf7     = 1 << 6,\tab\cf6 ///< set if automation write mode active (record parameter changes)\cf7\par
\tab\cf11 kVstAutomationReading\cf7     = 1 << 7,\tab\cf6 ///< set if automation read mode active (play parameter changes)\cf7\par
\tab\cf11 kVstNanosValid\cf7            = 1 << 8,\tab\cf6 ///< VstTimeInfo::nanoSeconds valid\cf7\par
\tab\cf11 kVstPpqPosValid\cf7           = 1 << 9,\tab\cf6 ///< VstTimeInfo::ppqPos valid\cf7\par
\tab\cf11 kVstTempoValid\cf7            = 1 << 10,\tab\cf6 ///< VstTimeInfo::tempo valid\cf7\par
\tab\cf11 kVstBarsValid\cf7             = 1 << 11,\tab\cf6 ///< VstTimeInfo::barStartPos valid\cf7\par
\tab\cf11 kVstCyclePosValid\cf7         = 1 << 12,\tab\cf6 ///< VstTimeInfo::cycleStartPos and VstTimeInfo::cycleEndPos valid\cf7\par
\tab\cf11 kVstTimeSigValid\cf7          = 1 << 13,\tab\cf6 ///< VstTimeInfo::timeSigNumerator and VstTimeInfo::timeSigDenominator valid\cf7\par
\tab\cf11 kVstSmpteValid\cf7            = 1 << 14,\tab\cf6 ///< VstTimeInfo::smpteOffset and VstTimeInfo::smpteFrameRate valid\cf7\par
\tab\cf11 kVstClockValid\cf7            = 1 << 15\tab\cf6 ///< VstTimeInfo::samplesToNextClock valid\cf7\par
\cf6 //-------------------------------------------------------------------------------------------------------\cf7\par
\};\par
\cf0\highlight0\f0\fs20\par
\par
AHA!!!!!!!!!!!!!!!!!!!!! TRUNCATED 64-BIT POINTER!!!!!!!\par
\par
\par
FINALLY A BREAKTHROUGH!  Robert at Sugar Bytes graciously sent me a debug version of Turnado, with symbols.  Using this I was able to diagnose the access violation:\par
\par

\pard\sb100\sa100\cf7\f6\fs24 First-chance exception at 0x00007FFCFEF3BF9E (Turnado.dll) in BASSASIOTurnadoTest.exe: 0xC0000005: Access violation reading location \cf12 0x0000000071B6C5E0\cf7 .\par

\pard\cf0\f0\fs20\par
Looking at the crashing frame in Turnado, it is clearly related to mVstTimeInfo:\par
\par

\pard\sb100\sa100\f2\fs24 + mVstTimeInfo \cf12 0x0000000071b6c5c0\cf0  \{samplePos=??? sampleRate=??? nanoSeconds=??? ...\} VstTimeInfo *\par

\pard\f0\fs20\par
So I set a breakpoint in BassVst's audioMasterCallbackImpl and looked at exactly where that value is returned:\par
\par
\cf7\highlight8\f5\fs16\tab\tab\cf1 case\cf7  \cf11 audioMasterGetTime\cf7 :\par
\tab\tab\tab calcVstTimeInfo(this_, \cf13 value\cf7 );\par
\tab\tab\tab ret =(\cf2 VstIntPtr\cf7 )&this_->vstTimeInfo;\cf6 // the structure needs to be valid "a moment"; it is overwritten on the next call to audioMasterGetTime\cf7\par
\tab\tab\tab\cf1 break\cf7 ;\cf0\highlight0\f0\fs20\par
\par
And I looked at the values of these locals as of the "break" statement:\par
\par
+\tab\tab this_\tab 0x000000041ff98bd0 \{type=0x00000000 vstHandle=0x1ff98bd0 channelHandle=0x80000002 ...\}\tab BASS_VST_PLUGIN *\par
\tab\tab ret\tab 0x1ff98f20\tab long\par
\par
And there it is.  On my Windows 8.1 system, the virtual address of the this_ object is outside the lowest 4GB of the address space.  And the VstIntPtr data type is a C++ long, only 32 bits!!!  So the pointer is getting truncated, and when Turnado dereferences it, it hits an earth-shattering KABOOM.\par
\par
This may explain why Bernd was not seeing this issue -- he is on Win7 which may not be so proactive about virtual addresses above the first 4GB.\par
\par
Great!  Problem solved!  Only, I am now trying to force BassVst to rebuild with a 64-bit version of the VstIntPtr type, and for some reason, it is refusing to cooperate.  I undefined WIN32, I defined VST_64BIT_PLATFORM, I even did this terrible hack\line\par
\cf6\highlight8\f5\fs16 // HOLOFUNK HACK // #if VST_64BIT_PLATFORM\cf7\par
\cf1 typedef\cf7  \cf2 VstInt64\cf7  \cf2 VstIntPtr\cf7 ;\tab\tab\tab\cf6 ///< platform-dependent integer type, same size as pointer\cf7\par
\cf6 // HOLOFUNK HACK // #else\cf7\par
\cf6 // HOLOFUNK HACK // typedef VstInt32 VstIntPtr;\tab\tab\tab ///< platform-dependent integer type, same size as pointer\cf7\par
\cf6 // HOLOFUNK HACK // #endif\cf0\highlight0\f0\fs20\par
\par
I commented out every typedef for VstIntPtr except the 64-bit one.\par
\par
And \i still,\i0  when I compile the BassVst project and run it in my test app, the VstIntPtr type is only 32 bits -- a plain "long", as above.\par
\par
Here is a complete archive of my BassVst project.  If anyone can tell me why it is not compiling VstIntPtr as a true 64-bit type, it would be immensely amazing.  \par
\par
{{\field{\*\fldinst{HYPERLINK http://unrealities.com/holofunk/BassVst_RobJellinghaus_20150423.zip }}{\fldrslt{http://unrealities.com/holofunk/BassVst_RobJellinghaus_20150423.zip\ul0\cf0}}}}\f0\fs20\par
\par
This is the only thing standing in the way of unblocking this issue.  Now I am kicking myself for not looking this closely much sooner... but better late than never!  rv, Bernd, Ian, do you get real 64-bit VstIntPtr definitions when you build this library, and if so, how exactly???\par
\par
\par
{{\field{\*\fldinst{HYPERLINK ftp://robj:iQZwkB6M@unrealities.com/ }}{\fldrslt{ftp://robj:iQZwkB6M@unrealities.com/\ul0\cf0}}}}\f0\fs20\par
\par
\par
OK turns out to be just THAT ONE SIMPLE LONG RET VARIABLE.\par
\par
- fix up ASIO device setup dialog so it sets up the selected device each time the device combo box changes.  looks like can't query channels until device is set (which seems reasonable really).  maybe can set the device before actually initialzing asio with device id?  will find out.\par
\par
- get program switching working in BATT\par
\par
...ok, fucking insanity.  switching between programs 0 and 1 seems to rotate through different program banks.  OR SOMETHING.  anyway totally batshit makes no sense and I can just write to the motherfucker and fuck it.  At least it is very very debuggable and I have my bassvst project building and binplacing properly YAY!\par
\par
wow. weird.  taking AAA1 out of the Factory 3 Presets folder totally resolved the issue with flipping back and forth between programs 0 and 1, but made it clear it is only reporting 16 programs when there are 15 in the Factory 3 folder alone.  Why?  Let's dig into BassVst because I DON'T TRUST THAT SHIT.\par
\par
\b YAAAAAYYYY!!!!!   Advice from Turnado people WORKED!\par
\b0\par
- try undoing the hack in calcVstTime around the final flag - \b DONE\b0\par
\par
- verify getting the effects we expect (resetting other ones to zero unexpectedly?  how the hell does my parameter stuff work persistently?) - answer: BATT just created a new map on every slider drag; Holofunk set up a private effect map in the EffectSpaceModel and shared that out to the microphone etc.  So Holofunk should be getting this right.\par
\par
- look into why doesn't make a sound until the program is touched -- DON'T CARE\par
\par
- try loading BASSASIOTurnadoTest on laptop, see what we get - getting close on that one but sharpdx.targets hassle\par
\tab - nope\par
\par
- effect labels never completely fade - \b FIXED\b0\par
- effect knob goes away for some reason or never shows up - \b FIXED\b0  (was shitty unknown arm pose fail)\par
- shoulder detection is such crap it thinks it is mouth sometimes - \b FIXED\b0\par
\par

\pard\sa200\sl276\slmult1\f7\fs22\lang9\par
DONEDATE 2015/05/07:\par
\par
}
 